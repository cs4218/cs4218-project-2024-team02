
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for cs4218-project-2024-team02/playwright-report/trace/sw.bundle.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">cs4218-project-2024-team02/playwright-report/trace</a> sw.bundle.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/2064</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/1501</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/382</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/4</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">var Cr=<span class="cstat-no" title="statement not covered" >Object.defineProperty;</span>var Dr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,t,e)=&gt;<span class="cstat-no" title="statement not covered" >t in n?Cr(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;</span></span>var M=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,t,e)=&gt;(<span class="cstat-no" title="statement not covered" >Dr(n,typeof t!="symbol"?t+"":t,e),e)</span>;</span>function <span class="fstat-no" title="function not covered" >Ir(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >new Array(t.length).fill(0);<span class="cstat-no" title="statement not covered" ></span>return new Array(t.length).fill(0).map(<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >e[s]=i/a*t[s]*1e3,n(e.reduce(<span class="fstat-no" title="function not covered" >(o</span>,l)=&gt;<span class="cstat-no" title="statement not covered" >o+l,</span>0),1e3)}</span>)</span>}</span>class Nr{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,r){<span class="cstat-no" title="statement not covered" >M(this,"_snapshots");<span class="cstat-no" title="statement not covered" >M</span>(this,"_index");<span class="cstat-no" title="statement not covered" >M</span>(this,"snapshotName");<span class="cstat-no" title="statement not covered" >M</span>(this,"_resources");<span class="cstat-no" title="statement not covered" >M</span>(this,"_snapshot");<span class="cstat-no" title="statement not covered" >M</span>(this,"_callId");<span class="cstat-no" title="statement not covered" >t</span>his._resources=t,this._snapshots=e,this._index=r,this._snapshot=e[r],this._callId=e[r].callId,this.snapshotName=e[r].snapshotName}<span class="fstat-no" title="function not covered" ></span>sn</span>apshot(){<span class="cstat-no" title="statement not covered" >return this._snapshots[this._index]}<span class="fstat-no" title="function not covered" ></span>vi</span>ewport(){<span class="cstat-no" title="statement not covered" >return this._snapshots[this._index].viewport}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){const t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,a,o,l)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof i=="string"){const _=<span class="cstat-no" title="statement not covered" >Fr(i);<span class="cstat-no" title="statement not covered" ></span>return o==="STYLE"||o==="style"?Hr(_):_}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!i._string)<span class="cstat-no" title="statement not covered" >if(Array.isArray(i[0])){const _=<span class="cstat-no" title="statement not covered" >a-i[0][0];<span class="cstat-no" title="statement not covered" ></span>if(_&gt;=0&amp;&amp;_&lt;=a){const d=<span class="cstat-no" title="statement not covered" >Ur(this._snapshots[_]),</span>p=<span class="cstat-no" title="statement not covered" >i[0][1];<span class="cstat-no" title="statement not covered" ></span>p&gt;=0&amp;&amp;p&lt;d.length&amp;&amp;(i._string=t(d[p],_,o,l))}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(typeof i[0]=="string"){const _=<span class="cstat-no" title="statement not covered" >i[0]==="NOSCRIPT"?"X-NOSCRIPT":i[0],</span>d=<span class="cstat-no" title="statement not covered" >Object.entries(i[1]||{}),</span>p=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>p.push("&lt;",_);c</span>onst m=<span class="cstat-no" title="statement not covered" >"__playwright_current_src__",</span>g=<span class="cstat-no" title="statement not covered" >_==="IFRAME"||_==="FRAME",</span>x=<span class="cstat-no" title="statement not covered" >_==="A",</span>f=<span class="cstat-no" title="statement not covered" >_==="IMG",</span>c=<span class="cstat-no" title="statement not covered" >f&amp;&amp;d.some(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >h[0]===m)</span>,</span>u=<span class="cstat-no" title="statement not covered" >_==="SOURCE"&amp;&amp;o==="PICTURE"&amp;&amp;(l==null?void 0:l.some(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >h[0]===m)</span>);<span class="cstat-no" title="statement not covered" ></span>for(const[h,w]of d){let y=<span class="cstat-no" title="statement not covered" >h;<span class="cstat-no" title="statement not covered" ></span>g&amp;&amp;h.toLowerCase()==="src"&amp;&amp;(y="__playwright_src__"),f&amp;&amp;h===m&amp;&amp;(y="src"),["src","srcset"].includes(h.toLowerCase())&amp;&amp;(c||u)&amp;&amp;(y="_"+y);l</span>et O=<span class="cstat-no" title="statement not covered" >w;<span class="cstat-no" title="statement not covered" ></span>x&amp;&amp;h.toLowerCase()==="href"?O="link://"+w:(h.toLowerCase()==="href"||h.toLowerCase()==="src"||h===m)&amp;&amp;(O=Qe(w)),p.push(" ",y,'="',Lr(O),'"')}<span class="cstat-no" title="statement not covered" ></span>p</span>.push("&gt;");<span class="cstat-no" title="statement not covered" >f</span>or(let h=<span class="cstat-no" title="statement not covered" >2;</span>h&lt;i.length;h++)<span class="cstat-no" title="statement not covered" >p.push(t(i[h],a,_,d));<span class="cstat-no" title="statement not covered" >P</span></span>r.has(_)||p.push("&lt;/",_,"&gt;"),i._string=p.join("")}</span>else <span class="cstat-no" title="statement not covered" >i._string="";<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn i._string}</span>,</span>e=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>let r=<span class="cstat-no" title="statement not covered" >t(e.html,this._index,void 0,void 0);<span class="cstat-no" title="statement not covered" ></span>return r?(r=(e.doctype?`&lt;!DOCTYPE ${e.doctype}&gt;`:"")+["&lt;style&gt;*,*::before,*::after { visibility: hidden }&lt;/style&gt;",`&lt;script&gt;${Mr(this._callId,this.snapshotName)}&lt;\/script&gt;`].join("")+r,{html:r,pageId:e.pageId,frameId:e.frameId,index:this._index}):{html:"",pageId:e.pageId,frameId:e.frameId,index:this._index}}<span class="fstat-no" title="function not covered" ></span>re</span>sourceByUrl(t,e){const r=<span class="cstat-no" title="statement not covered" >this._snapshot;</span>let s,i;<span class="cstat-no" title="statement not covered" >for(const o of this._resources){<span class="cstat-no" title="statement not covered" >if(typeof o._monotonicTime=="number"&amp;&amp;o._monotonicTime&gt;=r.timestamp)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>.response.status!==304&amp;&amp;o.request.url===t&amp;&amp;o.request.method===e&amp;&amp;(o._frameref===r.frameId?s=o:i=o)}</span>l</span>et a=<span class="cstat-no" title="statement not covered" >s??i;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;e.toUpperCase()==="GET"){<span class="cstat-no" title="statement not covered" >for(const o of r.resourceOverrides)<span class="cstat-no" title="statement not covered" >if(t===o.url&amp;&amp;o.sha1){<span class="cstat-no" title="statement not covered" >a={...a,response:{...a.response,content:{...a.response.content,_sha1:o.sha1}}};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn a}</span>}const Pr=<span class="cstat-no" title="statement not covered" >new Set(["AREA","BASE","BR","COL","COMMAND","EMBED","HR","IMG","INPUT","KEYGEN","LINK","MENUITEM","META","PARAM","SOURCE","TRACK","WBR"]),</span>xn=<span class="cstat-no" title="statement not covered" >{"&amp;":"&amp;amp;","&lt;":"&amp;lt;","&gt;":"&amp;gt;",'"':"&amp;quot;","'":"&amp;#39;"};</span>function <span class="fstat-no" title="function not covered" >Lr(</span>n){<span class="cstat-no" title="statement not covered" >return n.replace(/[&amp;&lt;&gt;"']/ug,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >xn[t])</span>}</span>function <span class="fstat-no" title="function not covered" >Fr(</span>n){<span class="cstat-no" title="statement not covered" >return n.replace(/[&amp;&lt;]/ug,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >xn[t])</span>}</span>function <span class="fstat-no" title="function not covered" >Ur(</span>n){<span class="cstat-no" title="statement not covered" >if(!n._nodes){const t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(typeof r=="string")<span class="cstat-no" title="statement not covered" >t.push(r);e</span>lse <span class="cstat-no" title="statement not covered" >if(typeof r[0]=="string"){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >2;</span>s&lt;r.length;s++)<span class="cstat-no" title="statement not covered" >e(r[s]);<span class="cstat-no" title="statement not covered" >t</span></span>.push(r)}</span>}</span></span>;<span class="cstat-no" title="statement not covered" ></span>e(n.html),n._nodes=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n._nodes}</span>function <span class="fstat-no" title="function not covered" >Mr(</span>...n){function <span class="fstat-no" title="function not covered" >t(</span>e,...r){const s=<span class="cstat-no" title="statement not covered" >"Recorded click position in absolute coordinates did not match the center of the clicked element. This is likely due to a difference between the test runner and the trace viewer operating systems.",</span>i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >p=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const m of p.querySelectorAll("[__playwright_scroll_top_]"))<span class="cstat-no" title="statement not covered" >i.push(m);<span class="cstat-no" title="statement not covered" >f</span></span>or(const m of p.querySelectorAll("[__playwright_scroll_left_]"))<span class="cstat-no" title="statement not covered" >a.push(m);<span class="cstat-no" title="statement not covered" >f</span></span>or(const m of p.querySelectorAll("[__playwright_value_]")){const g=<span class="cstat-no" title="statement not covered" >m;<span class="cstat-no" title="statement not covered" ></span>g.type!=="file"&amp;&amp;(g.value=g.getAttribute("__playwright_value_")),m.removeAttribute("__playwright_value_")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const m of p.querySelectorAll("[__playwright_checked_]"))<span class="cstat-no" title="statement not covered" >m.checked=m.getAttribute("__playwright_checked_")==="true",m.removeAttribute("__playwright_checked_");<span class="cstat-no" title="statement not covered" >f</span></span>or(const m of p.querySelectorAll("[__playwright_selected_]"))<span class="cstat-no" title="statement not covered" >m.selected=m.getAttribute("__playwright_selected_")==="true",m.removeAttribute("__playwright_selected_");<span class="cstat-no" title="statement not covered" >f</span></span>or(const m of r)<span class="cstat-no" title="statement not covered" >for(const g of p.querySelectorAll(`[__playwright_target__="${m}"]`)){const x=<span class="cstat-no" title="statement not covered" >g.style;<span class="cstat-no" title="statement not covered" ></span>x.outline="2px solid #006ab1",x.backgroundColor="#6fa8dc7f",o.push(g)}<span class="cstat-no" title="statement not covered" ></span>f</span></span>or(const m of p.querySelectorAll("iframe, frame")){const g=<span class="cstat-no" title="statement not covered" >m.getAttribute("__playwright_src__");<span class="cstat-no" title="statement not covered" ></span>if(!g)<span class="cstat-no" title="statement not covered" >m.setAttribute("src",'data:text/html,&lt;body style="background: #ddd"&gt;&lt;/body&gt;');e</span>lse{const x=<span class="cstat-no" title="statement not covered" >new URL(e(window.location.href)),</span>f=<span class="cstat-no" title="statement not covered" >x.pathname.lastIndexOf("/snapshot/");<span class="cstat-no" title="statement not covered" ></span>f!==-1&amp;&amp;(x.pathname=x.pathname.substring(0,f+1)),x.pathname+=g.substring(1),m.setAttribute("src",x.toString())}</span>}</span>{</span>const m=<span class="cstat-no" title="statement not covered" >p.querySelector("body[__playwright_custom_elements__]");<span class="cstat-no" title="statement not covered" ></span>if(m&amp;&amp;window.customElements){const g=<span class="cstat-no" title="statement not covered" >(m.getAttribute("__playwright_custom_elements__")||"").split(",");<span class="cstat-no" title="statement not covered" ></span>for(const x of g)<span class="cstat-no" title="statement not covered" >window.customElements.define(x,class extends HTMLElement{})}</span></span>}<span class="cstat-no" title="statement not covered" ></span>for(const m of p.querySelectorAll("template[__playwright_shadow_root_]")){const g=<span class="cstat-no" title="statement not covered" >m,</span>x=<span class="cstat-no" title="statement not covered" >g.parentElement.attachShadow({mode:"open"});<span class="cstat-no" title="statement not covered" ></span>x.appendChild(g.content),g.remove(),l(x)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("adoptedStyleSheets"in p){const m=<span class="cstat-no" title="statement not covered" >[...p.adoptedStyleSheets];<span class="cstat-no" title="statement not covered" ></span>for(const g of p.querySelectorAll("template[__playwright_style_sheet_]")){const x=<span class="cstat-no" title="statement not covered" >g,</span>f=<span class="cstat-no" title="statement not covered" >new CSSStyleSheet;<span class="cstat-no" title="statement not covered" ></span>f.replaceSync(x.getAttribute("__playwright_style_sheet_")),m.push(f)}<span class="cstat-no" title="statement not covered" ></span>p</span>.adoptedStyleSheets=m}</span>}</span>,</span>_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >window.removeEventListener("load",_);<span class="cstat-no" title="statement not covered" >f</span>or(const m of i)<span class="cstat-no" title="statement not covered" >m.scrollTop=+m.getAttribute("__playwright_scroll_top_"),m.removeAttribute("__playwright_scroll_top_");<span class="cstat-no" title="statement not covered" >f</span></span>or(const m of a)<span class="cstat-no" title="statement not covered" >m.scrollLeft=+m.getAttribute("__playwright_scroll_left_"),m.removeAttribute("__playwright_scroll_left_");<span class="cstat-no" title="statement not covered" >d</span></span>ocument.styleSheets[0].disabled=!0;c</span>onst p=<span class="cstat-no" title="statement not covered" >new URL(window.location.href).searchParams;<span class="cstat-no" title="statement not covered" ></span>if(p.get("pointX")&amp;&amp;p.get("pointY")){const m=<span class="cstat-no" title="statement not covered" >+p.get("pointX"),</span>g=<span class="cstat-no" title="statement not covered" >+p.get("pointY"),</span>x=<span class="cstat-no" title="statement not covered" >o.length&gt;0,</span>f=<span class="cstat-no" title="statement not covered" >document.documentElement?[document.documentElement]:[];<span class="cstat-no" title="statement not covered" ></span>for(const c of x?o:f){const u=<span class="cstat-no" title="statement not covered" >document.createElement("x-pw-pointer");<span class="cstat-no" title="statement not covered" ></span>if(u.style.position="fixed",u.style.backgroundColor="#f44336",u.style.width="20px",u.style.height="20px",u.style.borderRadius="10px",u.style.margin="-10px 0 0 -10px",u.style.zIndex="2147483646",u.style.display="flex",u.style.alignItems="center",u.style.justifyContent="center",x){const h=<span class="cstat-no" title="statement not covered" >c.getBoundingClientRect(),</span>w=<span class="cstat-no" title="statement not covered" >h.left+h.width/2,</span>y=<span class="cstat-no" title="statement not covered" >h.top+h.height/2;<span class="cstat-no" title="statement not covered" ></span>if(u.style.left=w+"px",u.style.top=y+"px",Math.abs(w-m)&gt;=10||Math.abs(y-g)&gt;=10){const O=<span class="cstat-no" title="statement not covered" >document.createElement("x-pw-pointer-warning");<span class="cstat-no" title="statement not covered" ></span>O.textContent="⚠",O.style.fontSize="19px",O.style.color="white",O.style.marginTop="-3.5px",O.style.userSelect="none",u.appendChild(O),u.setAttribute("title",s)}</span>}</span>else <span class="cstat-no" title="statement not covered" >u.style.left=m+"px",u.style.top=g+"px";<span class="cstat-no" title="statement not covered" >d</span></span>ocument.documentElement.appendChild(u)}</span>}</span>}</span>,</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l(document);<span class="cstat-no" title="statement not covered" ></span></span>window.addEventListener("load",_),window.addEventListener("DOMContentLoaded",d)}<span class="cstat-no" title="statement not covered" ></span>return`</span>
(${t.toString()})(${ze.toString()}${n.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >`, "${e}"`)</span>.join("")})`}const En=<span class="cstat-no" title="statement not covered" >["about:","blob:","data:","file:","ftp:","http:","https:","mailto:","sftp:","ws:","wss:"],</span>kt=<span class="cstat-no" title="statement not covered" >"http://playwright.bloburl/#";</span>function <span class="fstat-no" title="function not covered" >Qe(</span>n){<span class="cstat-no" title="statement not covered" >n.startsWith(kt)&amp;&amp;(n=n.substring(kt.length));<span class="cstat-no" title="statement not covered" >t</span>ry{const t=<span class="cstat-no" title="statement not covered" >new URL(n);<span class="cstat-no" title="statement not covered" ></span>if(t.protocol==="javascript:"||t.protocol==="vbscript:")<span class="cstat-no" title="statement not covered" >return"javascript:void(0)";<span class="cstat-no" title="statement not covered" >i</span></span>f(!(t.protocol==="blob:")&amp;&amp;En.includes(t.protocol))<span class="cstat-no" title="statement not covered" >return n;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >"pw-"+t.protocol.slice(0,t.protocol.length-1);<span class="cstat-no" title="statement not covered" ></span>return t.protocol="https:",t.hostname=t.hostname?`${r}--${t.hostname}`:r,t.toString()}</span>catch{<span class="cstat-no" title="statement not covered" >return n}</span>}</span>const vr=<span class="cstat-no" title="statement not covered" >/url\(['"]?([\w-]+:)\/\//ig;</span>function <span class="fstat-no" title="function not covered" >Hr(</span>n){<span class="cstat-no" title="statement not covered" >return n.replace(vr,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >!(e==="blob:")&amp;&amp;En.includes(e)?t:t.replace(e+"//",`https://pw-${e.slice(0,-1)}--`))</span>}</span>function <span class="fstat-no" title="function not covered" >ze(</span>n){const t=<span class="cstat-no" title="statement not covered" >new URL(n);<span class="cstat-no" title="statement not covered" ></span>return t.pathname.endsWith("/snapshot.html")?t.searchParams.get("r"):n}</span>class Wr{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >M(this,"_snapshotStorage");<span class="cstat-no" title="statement not covered" >M</span>(this,"_resourceLoader");<span class="cstat-no" title="statement not covered" >M</span>(this,"_snapshotIds",new Map);<span class="cstat-no" title="statement not covered" >t</span>his._snapshotStorage=t,this._resourceLoader=e}<span class="fstat-no" title="function not covered" ></span>se</span>rveSnapshot(t,e,r){const s=<span class="cstat-no" title="statement not covered" >this._snapshot(t.substring(9),e);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return new Response(null,{status:404});c</span></span>onst i=<span class="cstat-no" title="statement not covered" >s.render();<span class="cstat-no" title="statement not covered" ></span>return this._snapshotIds.set(r,s),new Response(i.html,{status:200,headers:{"Content-Type":"text/html"}})}<span class="fstat-no" title="function not covered" ></span>se</span>rveSnapshotInfo(t,e){const r=<span class="cstat-no" title="statement not covered" >this._snapshot(t.substring(13),e);<span class="cstat-no" title="statement not covered" ></span>return this._respondWithJson(r?{viewport:r.viewport(),url:r.snapshot().frameUrl}:{error:"No snapshot found"})}<span class="fstat-no" title="function not covered" ></span>_s</span>napshot(t,e){const r=<span class="cstat-no" title="statement not covered" >e.get("name");<span class="cstat-no" title="statement not covered" ></span>return this._snapshotStorage.snapshotByName(t.slice(1),r)}<span class="fstat-no" title="function not covered" ></span>_r</span>espondWithJson(t){<span class="cstat-no" title="statement not covered" >return new Response(JSON.stringify(t),{status:200,headers:{"Cache-Control":"public, max-age=31536000","Content-Type":"application/json"}})}<span class="fstat-no" title="function not covered" ></span>as</span>ync serveResource(t,e,r){let s;const i=<span class="cstat-no" title="statement not covered" >this._snapshotIds.get(r);<span class="cstat-no" title="statement not covered" ></span>for(const g of t)<span class="cstat-no" title="statement not covered" >if(s=i==null?void 0:i.resourceByUrl(Br(g),e),s)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(!s)<span class="cstat-no" title="statement not covered" >return new Response(null,{status:404});c</span></span>onst a=<span class="cstat-no" title="statement not covered" >s.response.content._sha1,</span>o=<span class="cstat-no" title="statement not covered" >a?await this._resourceLoader(a)||new Blob([]):new Blob([]);</span>let l=<span class="cstat-no" title="statement not covered" >s.response.content.mimeType;<span class="cstat-no" title="statement not covered" ></span>/^text\/|^application\/(javascript|json)/.test(l)&amp;&amp;!l.includes("charset")&amp;&amp;(l=`${l}; charset=utf-8`);c</span>onst d=<span class="cstat-no" title="statement not covered" >new Headers;<span class="cstat-no" title="statement not covered" ></span>d.set("Content-Type",l);<span class="cstat-no" title="statement not covered" >f</span>or(const{name:g,value:x}of s.response.headers)<span class="cstat-no" title="statement not covered" >d.set(g,x);<span class="cstat-no" title="statement not covered" >d</span></span>.delete("Content-Encoding"),d.delete("Access-Control-Allow-Origin"),d.set("Access-Control-Allow-Origin","*"),d.delete("Content-Length"),d.set("Content-Length",String(o.size)),d.set("Cache-Control","public, max-age=31536000");c</span>onst{status:p}=<span class="cstat-no" title="statement not covered" >s.response,</span>m=<span class="cstat-no" title="statement not covered" >p===101||p===204||p===205||p===304;<span class="cstat-no" title="statement not covered" ></span>return new Response(m?null:o,{headers:d,status:s.response.status,statusText:s.response.statusText})}</span>}function <span class="fstat-no" title="function not covered" >Br(</span>n){<span class="cstat-no" title="statement not covered" >try{const t=<span class="cstat-no" title="statement not covered" >new URL(n);<span class="cstat-no" title="statement not covered" ></span>return t.hash="",t.toString()}</span>catch{<span class="cstat-no" title="statement not covered" >return n}</span>}</span>function <span class="fstat-no" title="function not covered" >jr(</span>n){const t=<span class="cstat-no" title="statement not covered" >new Map,</span>{files:e,stacks:r}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>for(const s of r){const[i,a]=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>t.set(`call@${i}`,a.map(<span class="fstat-no" title="function not covered" >o=</span>&gt;(<span class="cstat-no" title="statement not covered" >{file:e[o[0]],line:o[1],column:o[2],function:o[3]})</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >qr(</span>){<span class="cstat-no" title="statement not covered" >return{isPrimary:!1,traceUrl:"",startTime:Number.MAX_SAFE_INTEGER,endTime:0,browserName:"",options:{deviceScaleFactor:1,isMobile:!1,viewport:{width:1280,height:800}},pages:[],resources:[],actions:[],events:[],errors:[],stdio:[],hasSource:!1}}</span>class Gr{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >M(this,"_resources",[]);<span class="cstat-no" title="statement not covered" >M</span>(this,"_frameSnapshots",new Map)}<span class="fstat-no" title="function not covered" ></span>ad</span>dResource(t){<span class="cstat-no" title="statement not covered" >t.request.url=Qe(t.request.url),this._resources.push(t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dFrameSnapshot(t){<span class="cstat-no" title="statement not covered" >for(const s of t.resourceOverrides)<span class="cstat-no" title="statement not covered" >s.url=Qe(s.url);l</span></span>et e=<span class="cstat-no" title="statement not covered" >this._frameSnapshots.get(t.frameId);<span class="cstat-no" title="statement not covered" ></span>e||(e={raw:[],renderers:[]},this._frameSnapshots.set(t.frameId,e),t.isMainFrame&amp;&amp;this._frameSnapshots.set(t.pageId,e)),e.raw.push(t);c</span>onst r=<span class="cstat-no" title="statement not covered" >new Nr(this._resources,e.raw,e.raw.length-1);<span class="cstat-no" title="statement not covered" ></span>return e.renderers.push(r),r}<span class="fstat-no" title="function not covered" ></span>sn</span>apshotByName(t,e){const r=<span class="cstat-no" title="statement not covered" >this._frameSnapshots.get(t);<span class="cstat-no" title="statement not covered" ></span>return r==null?void 0:r.renderers.find(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.snapshotName===e)</span>}<span class="fstat-no" title="function not covered" ></span>sn</span>apshotsForTest(){<span class="cstat-no" title="statement not covered" >return[...this._frameSnapshots.keys()]}<span class="fstat-no" title="function not covered" ></span>fi</span>nalize(){<span class="cstat-no" title="statement not covered" >this._resources.sort(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >(t._monotonicTime||0)-(e._monotonicTime||0))</span>}</span>}class Yr{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >M(this,"contextEntries",[]);<span class="cstat-no" title="statement not covered" >M</span>(this,"pageEntries",new Map);<span class="cstat-no" title="statement not covered" >M</span>(this,"_snapshotStorage");<span class="cstat-no" title="statement not covered" >M</span>(this,"_version");<span class="cstat-no" title="statement not covered" >M</span>(this,"_backend");<span class="cstat-no" title="statement not covered" >M</span>(this,"_attachments",new Map);<span class="cstat-no" title="statement not covered" >M</span>(this,"_resourceToContentType",new Map);<span class="cstat-no" title="statement not covered" >M</span>(this,"_jsHandles",new Map);<span class="cstat-no" title="statement not covered" >M</span>(this,"_consoleObjects",new Map)}<span class="fstat-no" title="function not covered" ></span>as</span>ync load(t,e){var o,l;<span class="cstat-no" title="statement not covered" >this._backend=t;c</span>onst r=<span class="cstat-no" title="statement not covered" >[];</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const _ of await this._backend.entryNames()){const d=<span class="cstat-no" title="statement not covered" >_.match(/(.+)\.trace/);<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;r.push(d[1]||""),_.includes("src@")&amp;&amp;(s=!0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!r.length)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find .trace file");<span class="cstat-no" title="statement not covered" >t</span></span>his._snapshotStorage=new Gr;c</span>onst i=<span class="cstat-no" title="statement not covered" >r.length*3;</span>let a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const _ of r){const d=<span class="cstat-no" title="statement not covered" >qr(),</span>p=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>d.traceUrl=t.traceURL(),d.hasSource=s;c</span>onst m=<span class="cstat-no" title="statement not covered" >await this._backend.readText(_+".trace")||"";<span class="cstat-no" title="statement not covered" ></span>for(const f of m.split(`</span></span>
`))<span class="cstat-no" title="statement not covered" >this.appendEvent(d,p,f);<span class="cstat-no" title="statement not covered" >e</span>(++a,i);c</span>onst g=<span class="cstat-no" title="statement not covered" >await this._backend.readText(_+".network")||"";<span class="cstat-no" title="statement not covered" ></span>for(const f of g.split(`</span>
`))<span class="cstat-no" title="statement not covered" >this.appendEvent(d,p,f);<span class="cstat-no" title="statement not covered" >i</span>f(e(++a,i),d.actions=[...p.values()].sort(<span class="fstat-no" title="function not covered" >(f</span>,c)=&gt;<span class="cstat-no" title="statement not covered" >f.startTime-c.startTime)</span>,!t.isLive()){<span class="cstat-no" title="statement not covered" >for(const f of d.actions.slice().reverse())<span class="cstat-no" title="statement not covered" >if(!f.endTime&amp;&amp;!f.error)<span class="cstat-no" title="statement not covered" >for(const c of d.actions)<span class="cstat-no" title="statement not covered" >c.parentId===f.callId&amp;&amp;f.endTime&lt;c.endTime&amp;&amp;(f.endTime=c.endTime)}</span></span></span></span>c</span>onst x=<span class="cstat-no" title="statement not covered" >await this._backend.readText(_+".stacks");<span class="cstat-no" title="statement not covered" ></span>if(x){const f=<span class="cstat-no" title="statement not covered" >jr(JSON.parse(x));<span class="cstat-no" title="statement not covered" ></span>for(const c of d.actions)<span class="cstat-no" title="statement not covered" >c.stack=c.stack||f.get(c.callId)}<span class="cstat-no" title="statement not covered" ></span></span>e</span>(++a,i);<span class="cstat-no" title="statement not covered" >f</span>or(const f of d.resources)<span class="cstat-no" title="statement not covered" >(o=f.request.postData)!=null&amp;&amp;o._sha1&amp;&amp;this._resourceToContentType.set(f.request.postData._sha1,Ct(f.request.postData.mimeType)),(l=f.response.content)!=null&amp;&amp;l._sha1&amp;&amp;this._resourceToContentType.set(f.response.content._sha1,Ct(f.response.content.mimeType));<span class="cstat-no" title="statement not covered" >t</span></span>his.contextEntries.push(d)}<span class="cstat-no" title="statement not covered" ></span>this._snapshotStorage.finalize(),this._jsHandles.clear(),this._consoleObjects.clear()}<span class="fstat-no" title="function not covered" ></span>as</span>ync hasEntry(t){<span class="cstat-no" title="statement not covered" >return this._backend.hasEntry(t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync resourceForSha1(t){const e=<span class="cstat-no" title="statement not covered" >await this._backend.readBlob("resources/"+t);<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return new Blob([e],{type:this._resourceToContentType.get(t)||"application/octet-stream"})}<span class="fstat-no" title="function not covered" ></span></span>at</span>tachmentForSha1(t){<span class="cstat-no" title="statement not covered" >return this._attachments.get(t)}<span class="fstat-no" title="function not covered" ></span>st</span>orage(){<span class="cstat-no" title="statement not covered" >return this._snapshotStorage}<span class="fstat-no" title="function not covered" ></span>_p</span>ageEntry(t,e){let r=<span class="cstat-no" title="statement not covered" >this.pageEntries.get(e);<span class="cstat-no" title="statement not covered" ></span>return r||(r={screencastFrames:[]},this.pageEntries.set(e,r),t.pages.push(r)),r}<span class="fstat-no" title="function not covered" ></span>ap</span>pendEvent(t,e,r){<span class="cstat-no" title="statement not covered" >if(!r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this._modernize(JSON.parse(r));<span class="cstat-no" title="statement not covered" ></span>for(const i of s)<span class="cstat-no" title="statement not covered" >this._innerAppendEvent(t,e,i)}<span class="fstat-no" title="function not covered" ></span></span>_i</span>nnerAppendEvent(t,e,r){var s;<span class="cstat-no" title="statement not covered" >switch(r.type){case"context-options":{<span class="cstat-no" title="statement not covered" >this._version=r.version,t.isPrimary=!0,t.browserName=r.browserName,t.channel=r.channel,t.title=r.title,t.platform=r.platform,t.wallTime=r.wallTime,t.sdkLanguage=r.sdkLanguage,t.options=r.options,t.testIdAttributeName=r.testIdAttributeName;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"screencast-frame":{<span class="cstat-no" title="statement not covered" >this._pageEntry(t,r.pageId).screencastFrames.push(r);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"before":{<span class="cstat-no" title="statement not covered" >e.set(r.callId,{...r,type:"action",endTime:0,log:[]});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"input":{const i=<span class="cstat-no" title="statement not covered" >e.get(r.callId);<span class="cstat-no" title="statement not covered" ></span>i.inputSnapshot=r.inputSnapshot,i.point=r.point;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"log":{const i=<span class="cstat-no" title="statement not covered" >e.get(r.callId);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>.log.push({time:r.time,message:r.message});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"after":{const i=<span class="cstat-no" title="statement not covered" >e.get(r.callId);<span class="cstat-no" title="statement not covered" ></span>i.afterSnapshot=r.afterSnapshot,i.endTime=r.endTime,i.result=r.result,i.error=r.error,i.attachments=r.attachments,r.point&amp;&amp;(i.point=r.point);<span class="cstat-no" title="statement not covered" >f</span>or(const a of((s=r.attachments)==null?void 0:s.filter(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o.sha1)</span>)||[])<span class="cstat-no" title="statement not covered" >this._attachments.set(a.sha1,a);<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>case"action":{<span class="cstat-no" title="statement not covered" >e.set(r.callId,{...r,log:[]});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"event":{<span class="cstat-no" title="statement not covered" >t.events.push(r);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"stdout":{<span class="cstat-no" title="statement not covered" >t.stdio.push(r);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"stderr":{<span class="cstat-no" title="statement not covered" >t.stdio.push(r);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"error":{<span class="cstat-no" title="statement not covered" >t.errors.push(r);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"console":{<span class="cstat-no" title="statement not covered" >t.events.push(r);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"resource-snapshot":<span class="cstat-no" title="statement not covered" >this._snapshotStorage.addResource(r.snapshot),t.resources.push(r.snapshot);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"frame-snapshot":<span class="cstat-no" title="statement not covered" >this._snapshotStorage.addFrameSnapshot(r.snapshot);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>"</span>pageId"in r&amp;&amp;r.pageId&amp;&amp;this._pageEntry(t,r.pageId),(r.type==="action"||r.type==="before")&amp;&amp;(t.startTime=Math.min(t.startTime,r.startTime)),(r.type==="action"||r.type==="after")&amp;&amp;(t.endTime=Math.max(t.endTime,r.endTime)),r.type==="event"&amp;&amp;(t.startTime=Math.min(t.startTime,r.time),t.endTime=Math.max(t.endTime,r.time)),r.type==="screencast-frame"&amp;&amp;(t.startTime=Math.min(t.startTime,r.timestamp),t.endTime=Math.max(t.endTime,r.timestamp))}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize(t){<span class="cstat-no" title="statement not covered" >if(this._version===void 0)<span class="cstat-no" title="statement not covered" >return[t];c</span></span>onst e=<span class="cstat-no" title="statement not covered" >6;</span>let r=<span class="cstat-no" title="statement not covered" >[t];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >this._version;</span>s&lt;e;++s)<span class="cstat-no" title="statement not covered" >r=this[`_modernize_${s}_to_${s+1}`].call(this,r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_0_to_1(t){<span class="cstat-no" title="statement not covered" >for(const e of t)<span class="cstat-no" title="statement not covered" >e.type==="action"&amp;&amp;typeof e.metadata.error=="string"&amp;&amp;(e.metadata.error={error:{name:"Error",message:e.metadata.error}});<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_1_to_2(t){var e,r;<span class="cstat-no" title="statement not covered" >for(const s of t)<span class="cstat-no" title="statement not covered" >s.type!=="frame-snapshot"||!s.snapshot.isMainFrame||(s.snapshot.viewport=((r=(e=this.contextEntries[0])==null?void 0:e.options)==null?void 0:r.viewport)||{width:1280,height:720});<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_2_to_3(t){<span class="cstat-no" title="statement not covered" >for(const e of t){<span class="cstat-no" title="statement not covered" >if(e.type!=="resource-snapshot"||e.snapshot.request)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >e.snapshot;<span class="cstat-no" title="statement not covered" ></span>e.snapshot={_frameref:r.frameId,request:{url:r.url,method:r.method,headers:r.requestHeaders,postData:r.requestSha1?{_sha1:r.requestSha1}:void 0},response:{status:r.status,headers:r.responseHeaders,content:{mimeType:r.contentType,_sha1:r.responseSha1}},_monotonicTime:r.timestamp}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_3_to_4(t){const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const r of t){const s=<span class="cstat-no" title="statement not covered" >this._modernize_event_3_to_4(r);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;e.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_event_3_to_4(t){var r,s,i,a;<span class="cstat-no" title="statement not covered" >if(t.type!=="action"&amp;&amp;t.type!=="event")<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.metadata;<span class="cstat-no" title="statement not covered" ></span>return e.internal||e.method.startsWith("tracing")?null:t.type==="event"?e.method==="__create__"&amp;&amp;e.type==="ConsoleMessage"?{type:"object",class:e.type,guid:e.params.guid,initializer:e.params.initializer}:{type:"event",time:e.startTime,class:e.type,method:e.method,params:e.params,pageId:e.pageId}:{type:"action",callId:e.id,startTime:e.startTime,endTime:e.endTime,apiName:e.apiName||e.type+"."+e.method,class:e.type,method:e.method,params:e.params,wallTime:e.wallTime||Date.now(),log:e.log,beforeSnapshot:(r=e.snapshots.find(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o.title==="before")</span>)==null?void 0:r.snapshotName,inputSnapshot:(s=e.snapshots.find(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o.title==="input")</span>)==null?void 0:s.snapshotName,afterSnapshot:(i=e.snapshots.find(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >o.title==="after")</span>)==null?void 0:i.snapshotName,error:(a=e.error)==null?void 0:a.error,result:e.result,point:e.point,pageId:e.pageId}}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_4_to_5(t){const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const r of t){const s=<span class="cstat-no" title="statement not covered" >this._modernize_event_4_to_5(r);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;e.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_event_4_to_5(t){var e,r;<span class="cstat-no" title="statement not covered" >if(t.type==="event"&amp;&amp;t.method==="__create__"&amp;&amp;t.class==="JSHandle"&amp;&amp;this._jsHandles.set(t.params.guid,t.params.initializer),t.type==="object"){<span class="cstat-no" title="statement not covered" >if(t.class!=="ConsoleMessage")<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >(e=t.initializer.args)==null?void 0:e.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(i.guid){const a=<span class="cstat-no" title="statement not covered" >this._jsHandles.get(i.guid);<span class="cstat-no" title="statement not covered" ></span>return{preview:(a==null?void 0:a.preview)||"",value:""}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{preview:i.preview||"",value:i.value||""}}</span>);<span class="cstat-no" title="statement not covered" ></span>return this._consoleObjects.set(t.guid,{type:t.initializer.type,text:t.initializer.text,location:t.initializer.location,args:s}),null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.type==="event"&amp;&amp;t.method==="console"){const s=<span class="cstat-no" title="statement not covered" >this._consoleObjects.get(((r=t.params.message)==null?void 0:r.guid)||"");<span class="cstat-no" title="statement not covered" ></span>return s?{type:"console",time:t.time,pageId:t.pageId,messageType:s.type,text:s.text,args:s.args,location:s.location}:null}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>_m</span>odernize_5_to_6(t){const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const r of t)<span class="cstat-no" title="statement not covered" >if(e.push(r),!(r.type!=="after"||!r.log.length))<span class="cstat-no" title="statement not covered" >for(const s of r.log)<span class="cstat-no" title="statement not covered" >e.push({type:"log",callId:r.callId,message:s,time:-1});<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn e}</span>}function <span class="fstat-no" title="function not covered" >Ct(</span>n){const t=<span class="cstat-no" title="statement not covered" >n.match(/^(.*);\s*charset=.*$/);<span class="cstat-no" title="statement not covered" ></span>return t?t[1]:n}</span>const Vr=<span class="cstat-no" title="statement not covered" >15,</span>L=<span class="cstat-no" title="statement not covered" >0,</span>z=<span class="cstat-no" title="statement not covered" >1,</span>Zr=<span class="cstat-no" title="statement not covered" >2,</span>V=<span class="cstat-no" title="statement not covered" >-2,</span>W=<span class="cstat-no" title="statement not covered" >-3,</span>Dt=<span class="cstat-no" title="statement not covered" >-4,</span>ee=<span class="cstat-no" title="statement not covered" >-5,</span>Z=<span class="cstat-no" title="statement not covered" >[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],</span>Tn=<span class="cstat-no" title="statement not covered" >1440,</span>Kr=<span class="cstat-no" title="statement not covered" >0,</span>Xr=<span class="cstat-no" title="statement not covered" >4,</span>$r=<span class="cstat-no" title="statement not covered" >9,</span>Jr=<span class="cstat-no" title="statement not covered" >5,</span>Qr=<span class="cstat-no" title="statement not covered" >[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],</span>zr=<span class="cstat-no" title="statement not covered" >[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],</span>es=<span class="cstat-no" title="statement not covered" >[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],</span>ts=<span class="cstat-no" title="statement not covered" >[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],</span>ns=<span class="cstat-no" title="statement not covered" >[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],</span>rs=<span class="cstat-no" title="statement not covered" >[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],</span>te=<span class="cstat-no" title="statement not covered" >15;</span>function <span class="fstat-no" title="function not covered" >et(</span>){const n=<span class="cstat-no" title="statement not covered" >this;</span>let t,e,r,s,i,a;function <span class="fstat-no" title="function not covered" >o(</span>_,d,p,m,g,x,f,c,u,h,w){let y,O,b,A,S,R,E,T,D,k,P,N,C,v,F;<span class="cstat-no" title="statement not covered" >k=0,S=p;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >r[_[d+k]]++,k++,S--;w</span>hile(S!==0);<span class="cstat-no" title="statement not covered" >i</span>f(r[0]==p)<span class="cstat-no" title="statement not covered" >return f[0]=-1,c[0]=0,L;<span class="cstat-no" title="statement not covered" >f</span></span>or(T=c[0],R=1;R&lt;=te&amp;&amp;r[R]===0;R++);<span class="cstat-no" title="statement not covered" >f</span>or(E=R,T&lt;R&amp;&amp;(T=R),S=te;S!==0&amp;&amp;r[S]===0;S--);<span class="cstat-no" title="statement not covered" >f</span>or(b=S,T&gt;S&amp;&amp;(T=S),c[0]=T,v=1&lt;&lt;R;R&lt;S;R++,v&lt;&lt;=1)<span class="cstat-no" title="statement not covered" >if((v-=r[R])&lt;0)<span class="cstat-no" title="statement not covered" >return W;<span class="cstat-no" title="statement not covered" >i</span></span></span>f((v-=r[S])&lt;0)<span class="cstat-no" title="statement not covered" >return W;<span class="cstat-no" title="statement not covered" >f</span></span>or(r[S]+=v,a[1]=R=0,k=1,C=2;--S!==0;)<span class="cstat-no" title="statement not covered" >a[C]=R+=r[k],C++,k++;<span class="cstat-no" title="statement not covered" >S</span></span>=0,k=0;<span class="cstat-no" title="statement not covered" >d</span>o<span class="cstat-no" title="statement not covered" >(R=_[d+k])!==0&amp;&amp;(w[a[R]++]=S),k++;w</span>hile(++S&lt;p);<span class="cstat-no" title="statement not covered" >f</span>or(p=a[b],a[0]=S=0,k=0,A=-1,N=-T,i[0]=0,P=0,F=0;E&lt;=b;E++)<span class="cstat-no" title="statement not covered" >for(y=r[E];y--!==0;){<span class="cstat-no" title="statement not covered" >for(;E&gt;N+T;){<span class="cstat-no" title="statement not covered" >if(A++,N+=T,F=b-N,F=F&gt;T?T:F,(O=1&lt;&lt;(R=E-N))&gt;y+1&amp;&amp;(O-=y+1,C=E,R&lt;F))<span class="cstat-no" title="statement not covered" >for(;++R&lt;F&amp;&amp;!((O&lt;&lt;=1)&lt;=r[++C]);)<span class="cstat-no" title="statement not covered" >O-=r[C];<span class="cstat-no" title="statement not covered" >i</span></span></span>f(F=1&lt;&lt;R,h[0]+F&gt;Tn)<span class="cstat-no" title="statement not covered" >return W;<span class="cstat-no" title="statement not covered" >i</span></span>[A]=P=h[0],h[0]+=F,A!==0?(a[A]=S,s[0]=R,s[1]=T,R=S&gt;&gt;&gt;N-T,s[2]=P-i[A-1]-R,u.set(s,(i[A-1]+R)*3)):f[0]=P}<span class="cstat-no" title="statement not covered" ></span>f</span>or(s[1]=E-N,k&gt;=p?s[0]=192:w[k]&lt;m?(s[0]=w[k]&lt;256?0:96,s[2]=w[k++]):(s[0]=x[w[k]-m]+16+64,s[2]=g[w[k++]-m]),O=1&lt;&lt;E-N,R=S&gt;&gt;&gt;N;R&lt;F;R+=O)<span class="cstat-no" title="statement not covered" >u.set(s,(P+R)*3);<span class="cstat-no" title="statement not covered" >f</span></span>or(R=1&lt;&lt;E-1;S&amp;R;R&gt;&gt;&gt;=1)<span class="cstat-no" title="statement not covered" >S^=R;<span class="cstat-no" title="statement not covered" >f</span></span>or(S^=R,D=(1&lt;&lt;N)-1;(S&amp;D)!=a[A];)<span class="cstat-no" title="statement not covered" >A--,N-=T,D=(1&lt;&lt;N)-1}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn v!==0&amp;&amp;b!=1?ee:L}</span>function <span class="fstat-no" title="function not covered" >l(</span>_){let d;<span class="cstat-no" title="statement not covered" >for(t||(t=[],e=[],r=new Int32Array(te+1),s=[],i=new Int32Array(te),a=new Int32Array(te+1)),e.length&lt;_&amp;&amp;(e=[]),d=0;d&lt;_;d++)<span class="cstat-no" title="statement not covered" >e[d]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(d=0;d&lt;te+1;d++)<span class="cstat-no" title="statement not covered" >r[d]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(d=0;d&lt;3;d++)<span class="cstat-no" title="statement not covered" >s[d]=0;<span class="cstat-no" title="statement not covered" >i</span></span>.set(r.subarray(0,te),0),a.set(r.subarray(0,te+1),0)}<span class="cstat-no" title="statement not covered" ></span>n.inflate_trees_bits=<span class="fstat-no" title="function not covered" >fu</span>nction(_,d,p,m,g){let x;<span class="cstat-no" title="statement not covered" >return l(19),t[0]=0,x=o(_,0,19,19,null,null,p,d,m,t,e),x==W?g.msg="oversubscribed dynamic bit lengths tree":(x==ee||d[0]===0)&amp;&amp;(g.msg="incomplete dynamic bit lengths tree",x=W),x}</span>,n.inflate_trees_dynamic=<span class="fstat-no" title="function not covered" >fu</span>nction(_,d,p,m,g,x,f,c,u){let h;<span class="cstat-no" title="statement not covered" >return l(288),t[0]=0,h=o(p,0,_,257,es,ts,x,m,c,t,e),h!=L||m[0]===0?(h==W?u.msg="oversubscribed literal/length tree":h!=Dt&amp;&amp;(u.msg="incomplete literal/length tree",h=W),h):(l(288),h=o(p,_,d,0,ns,rs,f,g,c,t,e),h!=L||g[0]===0&amp;&amp;_&gt;257?(h==W?u.msg="oversubscribed distance tree":h==ee?(u.msg="incomplete distance tree",h=W):h!=Dt&amp;&amp;(u.msg="empty distance tree with lengths",h=W),h):L)}</span>}<span class="cstat-no" title="statement not covered" ></span>et.inflate_trees_fixed=<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,e,r){<span class="cstat-no" title="statement not covered" >return n[0]=$r,t[0]=Jr,e[0]=Qr,r[0]=zr,L}</span>;c</span>onst Ce=<span class="cstat-no" title="statement not covered" >0,</span>It=<span class="cstat-no" title="statement not covered" >1,</span>Nt=<span class="cstat-no" title="statement not covered" >2,</span>Pt=<span class="cstat-no" title="statement not covered" >3,</span>Lt=<span class="cstat-no" title="statement not covered" >4,</span>Ft=<span class="cstat-no" title="statement not covered" >5,</span>Ut=<span class="cstat-no" title="statement not covered" >6,</span>qe=<span class="cstat-no" title="statement not covered" >7,</span>Mt=<span class="cstat-no" title="statement not covered" >8,</span>De=<span class="cstat-no" title="statement not covered" >9;</span>function <span class="fstat-no" title="function not covered" >ss(</span>){const n=<span class="cstat-no" title="statement not covered" >this;</span>let t,e=<span class="cstat-no" title="statement not covered" >0,</span>r,s=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0,</span>_=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >0,</span>p,m=<span class="cstat-no" title="statement not covered" >0,</span>g,x=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >f(</span>c,u,h,w,y,O,b,A){let S,R,E,T,D,k,P,N,C,v,F,ge,I,le,U,H;<span class="cstat-no" title="statement not covered" >P=A.next_in_index,N=A.avail_in,D=b.bitb,k=b.bitk,C=b.write,v=C&lt;b.read?b.read-C-1:b.end-C,F=Z[c],ge=Z[u];<span class="cstat-no" title="statement not covered" >d</span>o{<span class="cstat-no" title="statement not covered" >for(;k&lt;20;)<span class="cstat-no" title="statement not covered" >N--,D|=(A.read_byte(P++)&amp;255)&lt;&lt;k,k+=8;<span class="cstat-no" title="statement not covered" >i</span></span>f(S=D&amp;F,R=h,E=w,H=(E+S)*3,(T=R[H])===0){<span class="cstat-no" title="statement not covered" >D&gt;&gt;=R[H+1],k-=R[H+1],b.win[C++]=R[H+2],v--;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>d</span>o{<span class="cstat-no" title="statement not covered" >if(D&gt;&gt;=R[H+1],k-=R[H+1],T&amp;16){<span class="cstat-no" title="statement not covered" >for(T&amp;=15,I=R[H+2]+(D&amp;Z[T]),D&gt;&gt;=T,k-=T;k&lt;15;)<span class="cstat-no" title="statement not covered" >N--,D|=(A.read_byte(P++)&amp;255)&lt;&lt;k,k+=8;<span class="cstat-no" title="statement not covered" >S</span></span>=D&amp;ge,R=y,E=O,H=(E+S)*3,T=R[H];<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >if(D&gt;&gt;=R[H+1],k-=R[H+1],T&amp;16){<span class="cstat-no" title="statement not covered" >for(T&amp;=15;k&lt;T;)<span class="cstat-no" title="statement not covered" >N--,D|=(A.read_byte(P++)&amp;255)&lt;&lt;k,k+=8;<span class="cstat-no" title="statement not covered" >i</span></span>f(le=R[H+2]+(D&amp;Z[T]),D&gt;&gt;=T,k-=T,v-=I,C&gt;=le)<span class="cstat-no" title="statement not covered" >U=C-le,C-U&gt;0&amp;&amp;2&gt;C-U?(b.win[C++]=b.win[U++],b.win[C++]=b.win[U++],I-=2):(b.win.set(b.win.subarray(U,U+2),C),C+=2,U+=2,I-=2);e</span>lse{<span class="cstat-no" title="statement not covered" >U=C-le;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >U+=b.end;w</span>hile(U&lt;0);<span class="cstat-no" title="statement not covered" >i</span>f(T=b.end-U,I&gt;T){<span class="cstat-no" title="statement not covered" >if(I-=T,C-U&gt;0&amp;&amp;T&gt;C-U)<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >b.win[C++]=b.win[U++];w</span>hile(--T!==0);e</span>lse <span class="cstat-no" title="statement not covered" >b.win.set(b.win.subarray(U,U+T),C),C+=T,U+=T,T=0;<span class="cstat-no" title="statement not covered" >U</span></span>=0}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(C-U&gt;0&amp;&amp;I&gt;C-U)<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" >b.win[C++]=b.win[U++];w</span>hile(--I!==0);e</span>lse <span class="cstat-no" title="statement not covered" >b.win.set(b.win.subarray(U,U+I),C),C+=I,U+=I,I=0;<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>else <span class="cstat-no" title="statement not covered" >if(!(T&amp;64))<span class="cstat-no" title="statement not covered" >S+=R[H+2],S+=D&amp;Z[T],H=(E+S)*3,T=R[H];e</span>lse <span class="cstat-no" title="statement not covered" >return A.msg="invalid distance code",I=A.avail_in-N,I=k&gt;&gt;3&lt;I?k&gt;&gt;3:I,N+=I,P-=I,k-=I&lt;&lt;3,b.bitb=D,b.bitk=k,A.avail_in=N,A.total_in+=P-A.next_in_index,A.next_in_index=P,b.write=C,W;w</span></span></span>hile(!0);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(T&amp;64)<span class="cstat-no" title="statement not covered" >return T&amp;32?(I=A.avail_in-N,I=k&gt;&gt;3&lt;I?k&gt;&gt;3:I,N+=I,P-=I,k-=I&lt;&lt;3,b.bitb=D,b.bitk=k,A.avail_in=N,A.total_in+=P-A.next_in_index,A.next_in_index=P,b.write=C,z):(A.msg="invalid literal/length code",I=A.avail_in-N,I=k&gt;&gt;3&lt;I?k&gt;&gt;3:I,N+=I,P-=I,k-=I&lt;&lt;3,b.bitb=D,b.bitk=k,A.avail_in=N,A.total_in+=P-A.next_in_index,A.next_in_index=P,b.write=C,W);<span class="cstat-no" title="statement not covered" >i</span></span>f(S+=R[H+2],S+=D&amp;Z[T],H=(E+S)*3,(T=R[H])===0){<span class="cstat-no" title="statement not covered" >D&gt;&gt;=R[H+1],k-=R[H+1],b.win[C++]=R[H+2],v--;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>while(!0)}</span>while(v&gt;=258&amp;&amp;N&gt;=10);<span class="cstat-no" title="statement not covered" >r</span>eturn I=A.avail_in-N,I=k&gt;&gt;3&lt;I?k&gt;&gt;3:I,N+=I,P-=I,k-=I&lt;&lt;3,b.bitb=D,b.bitk=k,A.avail_in=N,A.total_in+=P-A.next_in_index,A.next_in_index=P,b.write=C,L}<span class="cstat-no" title="statement not covered" ></span>n.init=<span class="fstat-no" title="function not covered" >fu</span>nction(c,u,h,w,y,O){<span class="cstat-no" title="statement not covered" >t=Ce,_=c,d=u,p=h,m=w,g=y,x=O,r=null}</span>,n.proc=<span class="fstat-no" title="function not covered" >fu</span>nction(c,u,h){let w,y,O,b=<span class="cstat-no" title="statement not covered" >0,</span>A=<span class="cstat-no" title="statement not covered" >0,</span>S=<span class="cstat-no" title="statement not covered" >0,</span>R,E,T,D;<span class="cstat-no" title="statement not covered" >for(S=u.next_in_index,R=u.avail_in,b=c.bitb,A=c.bitk,E=c.write,T=E&lt;c.read?c.read-E-1:c.end-E;;)<span class="cstat-no" title="statement not covered" >switch(t){case Ce:<span class="cstat-no" title="statement not covered" >if(T&gt;=258&amp;&amp;R&gt;=10&amp;&amp;(c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,h=f(_,d,p,m,g,x,c,u),S=u.next_in_index,R=u.avail_in,b=c.bitb,A=c.bitk,E=c.write,T=E&lt;c.read?c.read-E-1:c.end-E,h!=L)){<span class="cstat-no" title="statement not covered" >t=h==z?qe:De;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>=_,r=p,s=m,t=It;c</span>ase It:<span class="cstat-no" title="statement not covered" >for(w=i;A&lt;w;){<span class="cstat-no" title="statement not covered" >if(R!==0)<span class="cstat-no" title="statement not covered" >h=L;e</span>lse <span class="cstat-no" title="statement not covered" >return c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);<span class="cstat-no" title="statement not covered" >R</span></span>--,b|=(u.read_byte(S++)&amp;255)&lt;&lt;A,A+=8}<span class="cstat-no" title="statement not covered" ></span>i</span>f(y=(s+(b&amp;Z[w]))*3,b&gt;&gt;&gt;=r[y+1],A-=r[y+1],O=r[y],O===0){<span class="cstat-no" title="statement not covered" >a=r[y+2],t=Ut;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(O&amp;16){<span class="cstat-no" title="statement not covered" >o=O&amp;15,e=r[y+2],t=Nt;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(O&amp;64)){<span class="cstat-no" title="statement not covered" >i=O,s=y/3+r[y+2];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(O&amp;32){<span class="cstat-no" title="statement not covered" >t=qe;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t=De,u.msg="invalid literal/length code",h=W,c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);c</span>ase Nt:<span class="cstat-no" title="statement not covered" >for(w=o;A&lt;w;){<span class="cstat-no" title="statement not covered" >if(R!==0)<span class="cstat-no" title="statement not covered" >h=L;e</span>lse <span class="cstat-no" title="statement not covered" >return c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);<span class="cstat-no" title="statement not covered" >R</span></span>--,b|=(u.read_byte(S++)&amp;255)&lt;&lt;A,A+=8}<span class="cstat-no" title="statement not covered" ></span>e</span>+=b&amp;Z[w],b&gt;&gt;=w,A-=w,i=d,r=g,s=x,t=Pt;c</span>ase Pt:<span class="cstat-no" title="statement not covered" >for(w=i;A&lt;w;){<span class="cstat-no" title="statement not covered" >if(R!==0)<span class="cstat-no" title="statement not covered" >h=L;e</span>lse <span class="cstat-no" title="statement not covered" >return c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);<span class="cstat-no" title="statement not covered" >R</span></span>--,b|=(u.read_byte(S++)&amp;255)&lt;&lt;A,A+=8}<span class="cstat-no" title="statement not covered" ></span>i</span>f(y=(s+(b&amp;Z[w]))*3,b&gt;&gt;=r[y+1],A-=r[y+1],O=r[y],O&amp;16){<span class="cstat-no" title="statement not covered" >o=O&amp;15,l=r[y+2],t=Lt;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(O&amp;64)){<span class="cstat-no" title="statement not covered" >i=O,s=y/3+r[y+2];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t=De,u.msg="invalid distance code",h=W,c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);c</span>ase Lt:<span class="cstat-no" title="statement not covered" >for(w=o;A&lt;w;){<span class="cstat-no" title="statement not covered" >if(R!==0)<span class="cstat-no" title="statement not covered" >h=L;e</span>lse <span class="cstat-no" title="statement not covered" >return c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);<span class="cstat-no" title="statement not covered" >R</span></span>--,b|=(u.read_byte(S++)&amp;255)&lt;&lt;A,A+=8}<span class="cstat-no" title="statement not covered" ></span>l</span>+=b&amp;Z[w],b&gt;&gt;=w,A-=w,t=Ft;c</span>ase Ft:<span class="cstat-no" title="statement not covered" >for(D=E-l;D&lt;0;)<span class="cstat-no" title="statement not covered" >D+=c.end;<span class="cstat-no" title="statement not covered" >f</span></span>or(;e!==0;){<span class="cstat-no" title="statement not covered" >if(T===0&amp;&amp;(E==c.end&amp;&amp;c.read!==0&amp;&amp;(E=0,T=E&lt;c.read?c.read-E-1:c.end-E),T===0&amp;&amp;(c.write=E,h=c.inflate_flush(u,h),E=c.write,T=E&lt;c.read?c.read-E-1:c.end-E,E==c.end&amp;&amp;c.read!==0&amp;&amp;(E=0,T=E&lt;c.read?c.read-E-1:c.end-E),T===0)))<span class="cstat-no" title="statement not covered" >return c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);<span class="cstat-no" title="statement not covered" >c</span></span>.win[E++]=c.win[D++],T--,D==c.end&amp;&amp;(D=0),e--}<span class="cstat-no" title="statement not covered" ></span>t</span>=Ce;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Ut:<span class="cstat-no" title="statement not covered" >if(T===0&amp;&amp;(E==c.end&amp;&amp;c.read!==0&amp;&amp;(E=0,T=E&lt;c.read?c.read-E-1:c.end-E),T===0&amp;&amp;(c.write=E,h=c.inflate_flush(u,h),E=c.write,T=E&lt;c.read?c.read-E-1:c.end-E,E==c.end&amp;&amp;c.read!==0&amp;&amp;(E=0,T=E&lt;c.read?c.read-E-1:c.end-E),T===0)))<span class="cstat-no" title="statement not covered" >return c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);<span class="cstat-no" title="statement not covered" >h</span></span>=L,c.win[E++]=a,T--,t=Ce;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase qe:<span class="cstat-no" title="statement not covered" >if(A&gt;7&amp;&amp;(A-=8,R++,S--),c.write=E,h=c.inflate_flush(u,h),E=c.write,T=E&lt;c.read?c.read-E-1:c.end-E,c.read!=c.write)<span class="cstat-no" title="statement not covered" >return c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);<span class="cstat-no" title="statement not covered" >t</span></span>=Mt;c</span>ase Mt:<span class="cstat-no" title="statement not covered" >return h=z,c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);c</span>ase De:<span class="cstat-no" title="statement not covered" >return h=W,c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h);d</span>efault:<span class="cstat-no" title="statement not covered" >return h=V,c.bitb=b,c.bitk=A,u.avail_in=R,u.total_in+=S-u.next_in_index,u.next_in_index=S,c.write=E,c.inflate_flush(u,h)}</span>}</span></span>,n.free=<span class="fstat-no" title="function not covered" >fu</span>nction(){}}</span>const vt=<span class="cstat-no" title="statement not covered" >[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],</span>he=<span class="cstat-no" title="statement not covered" >0,</span>Ge=<span class="cstat-no" title="statement not covered" >1,</span>Ht=<span class="cstat-no" title="statement not covered" >2,</span>Wt=<span class="cstat-no" title="statement not covered" >3,</span>Bt=<span class="cstat-no" title="statement not covered" >4,</span>jt=<span class="cstat-no" title="statement not covered" >5,</span>Ie=<span class="cstat-no" title="statement not covered" >6,</span>Ne=<span class="cstat-no" title="statement not covered" >7,</span>qt=<span class="cstat-no" title="statement not covered" >8,</span>fe=<span class="cstat-no" title="statement not covered" >9;</span>function <span class="fstat-no" title="function not covered" >is(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >this;</span>let r=<span class="cstat-no" title="statement not covered" >he,</span>s=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>o;const l=<span class="cstat-no" title="statement not covered" >[0],</span>_=<span class="cstat-no" title="statement not covered" >[0],</span>d=<span class="cstat-no" title="statement not covered" >new ss;</span>let p=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >new Int32Array(Tn*3);</span>const g=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >new et;<span class="cstat-no" title="statement not covered" ></span>e.bitk=0,e.bitb=0,e.win=new Uint8Array(t),e.end=t,e.read=0,e.write=0,e.reset=<span class="fstat-no" title="function not covered" >fu</span>nction(f,c){<span class="cstat-no" title="statement not covered" >c&amp;&amp;(c[0]=g),r==Ie&amp;&amp;d.free(f),r=he,e.bitk=0,e.bitb=0,e.read=e.write=0}</span>,e.reset(n,null),e.inflate_flush=<span class="fstat-no" title="function not covered" >fu</span>nction(f,c){let u,h,w;<span class="cstat-no" title="statement not covered" >return h=f.next_out_index,w=e.read,u=(w&lt;=e.write?e.write:e.end)-w,u&gt;f.avail_out&amp;&amp;(u=f.avail_out),u!==0&amp;&amp;c==ee&amp;&amp;(c=L),f.avail_out-=u,f.total_out+=u,f.next_out.set(e.win.subarray(w,w+u),h),h+=u,w+=u,w==e.end&amp;&amp;(w=0,e.write==e.end&amp;&amp;(e.write=0),u=e.write-w,u&gt;f.avail_out&amp;&amp;(u=f.avail_out),u!==0&amp;&amp;c==ee&amp;&amp;(c=L),f.avail_out-=u,f.total_out+=u,f.next_out.set(e.win.subarray(w,w+u),h),h+=u,w+=u),f.next_out_index=h,e.read=w,c}</span>,e.proc=<span class="fstat-no" title="function not covered" >fu</span>nction(f,c){let u,h,w,y,O,b,A,S;<span class="cstat-no" title="statement not covered" >for(y=f.next_in_index,O=f.avail_in,h=e.bitb,w=e.bitk,b=e.write,A=b&lt;e.read?e.read-b-1:e.end-b;;){let R,E,T,D,k,P,N,C;<span class="cstat-no" title="statement not covered" >switch(r){case he:<span class="cstat-no" title="statement not covered" >for(;w&lt;3;){<span class="cstat-no" title="statement not covered" >if(O!==0)<span class="cstat-no" title="statement not covered" >c=L;e</span>lse <span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >O</span></span>--,h|=(f.read_byte(y++)&amp;255)&lt;&lt;w,w+=8}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(u=h&amp;7,p=u&amp;1,u&gt;&gt;&gt;1){case 0:<span class="cstat-no" title="statement not covered" >h&gt;&gt;&gt;=3,w-=3,u=w&amp;7,h&gt;&gt;&gt;=u,w-=u,r=Ge;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >R=[],E=[],T=[[]],D=[[]],et.inflate_trees_fixed(R,E,T,D),d.init(R[0],E[0],T[0],0,D[0],0),h&gt;&gt;&gt;=3,w-=3,r=Ie;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >h&gt;&gt;&gt;=3,w-=3,r=Wt;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >return h&gt;&gt;&gt;=3,w-=3,r=fe,f.msg="invalid block type",c=W,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c)}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase Ge:<span class="cstat-no" title="statement not covered" >for(;w&lt;32;){<span class="cstat-no" title="statement not covered" >if(O!==0)<span class="cstat-no" title="statement not covered" >c=L;e</span>lse <span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >O</span></span>--,h|=(f.read_byte(y++)&amp;255)&lt;&lt;w,w+=8}<span class="cstat-no" title="statement not covered" ></span>i</span>f((~h&gt;&gt;&gt;16&amp;65535)!=(h&amp;65535))<span class="cstat-no" title="statement not covered" >return r=fe,f.msg="invalid stored block lengths",c=W,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >s</span></span>=h&amp;65535,h=w=0,r=s!==0?Ht:p!==0?Ne:he;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Ht:<span class="cstat-no" title="statement not covered" >if(O===0||A===0&amp;&amp;(b==e.end&amp;&amp;e.read!==0&amp;&amp;(b=0,A=b&lt;e.read?e.read-b-1:e.end-b),A===0&amp;&amp;(e.write=b,c=e.inflate_flush(f,c),b=e.write,A=b&lt;e.read?e.read-b-1:e.end-b,b==e.end&amp;&amp;e.read!==0&amp;&amp;(b=0,A=b&lt;e.read?e.read-b-1:e.end-b),A===0)))<span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >i</span></span>f(c=L,u=s,u&gt;O&amp;&amp;(u=O),u&gt;A&amp;&amp;(u=A),e.win.set(f.read_buf(y,u),b),y+=u,O-=u,b+=u,A-=u,(s-=u)!==0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span>=p!==0?Ne:he;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase Wt:<span class="cstat-no" title="statement not covered" >for(;w&lt;14;){<span class="cstat-no" title="statement not covered" >if(O!==0)<span class="cstat-no" title="statement not covered" >c=L;e</span>lse <span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >O</span></span>--,h|=(f.read_byte(y++)&amp;255)&lt;&lt;w,w+=8}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i=u=h&amp;16383,(u&amp;31)&gt;29||(u&gt;&gt;5&amp;31)&gt;29)<span class="cstat-no" title="statement not covered" >return r=fe,f.msg="too many length or distance symbols",c=W,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >i</span></span>f(u=258+(u&amp;31)+(u&gt;&gt;5&amp;31),!o||o.length&lt;u)<span class="cstat-no" title="statement not covered" >o=[];e</span>lse <span class="cstat-no" title="statement not covered" >for(S=0;S&lt;u;S++)<span class="cstat-no" title="statement not covered" >o[S]=0;<span class="cstat-no" title="statement not covered" >h</span></span></span>&gt;&gt;&gt;=14,w-=14,a=0,r=Bt;c</span>ase Bt:<span class="cstat-no" title="statement not covered" >for(;a&lt;4+(i&gt;&gt;&gt;10);){<span class="cstat-no" title="statement not covered" >for(;w&lt;3;){<span class="cstat-no" title="statement not covered" >if(O!==0)<span class="cstat-no" title="statement not covered" >c=L;e</span>lse <span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >O</span></span>--,h|=(f.read_byte(y++)&amp;255)&lt;&lt;w,w+=8}<span class="cstat-no" title="statement not covered" ></span>o</span>[vt[a++]]=h&amp;7,h&gt;&gt;&gt;=3,w-=3}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;a&lt;19;)<span class="cstat-no" title="statement not covered" >o[vt[a++]]=0;<span class="cstat-no" title="statement not covered" >i</span></span>f(l[0]=7,u=x.inflate_trees_bits(o,l,_,m,f),u!=L)<span class="cstat-no" title="statement not covered" >return c=u,c==W&amp;&amp;(o=null,r=fe),e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >a</span></span>=0,r=jt;c</span>ase jt:<span class="cstat-no" title="statement not covered" >for(;u=i,!(a&gt;=258+(u&amp;31)+(u&gt;&gt;5&amp;31));){let v,F;<span class="cstat-no" title="statement not covered" >for(u=l[0];w&lt;u;){<span class="cstat-no" title="statement not covered" >if(O!==0)<span class="cstat-no" title="statement not covered" >c=L;e</span>lse <span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >O</span></span>--,h|=(f.read_byte(y++)&amp;255)&lt;&lt;w,w+=8}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u=m[(_[0]+(h&amp;Z[u]))*3+1],F=m[(_[0]+(h&amp;Z[u]))*3+2],F&lt;16)<span class="cstat-no" title="statement not covered" >h&gt;&gt;&gt;=u,w-=u,o[a++]=F;e</span>lse{<span class="cstat-no" title="statement not covered" >for(S=F==18?7:F-14,v=F==18?11:3;w&lt;u+S;){<span class="cstat-no" title="statement not covered" >if(O!==0)<span class="cstat-no" title="statement not covered" >c=L;e</span>lse <span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >O</span></span>--,h|=(f.read_byte(y++)&amp;255)&lt;&lt;w,w+=8}<span class="cstat-no" title="statement not covered" ></span>i</span>f(h&gt;&gt;&gt;=u,w-=u,v+=h&amp;Z[S],h&gt;&gt;&gt;=S,w-=S,S=a,u=i,S+v&gt;258+(u&amp;31)+(u&gt;&gt;5&amp;31)||F==16&amp;&amp;S&lt;1)<span class="cstat-no" title="statement not covered" >return o=null,r=fe,f.msg="invalid bit length repeat",c=W,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >F</span></span>=F==16?o[S-1]:0;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >o[S++]=F;w</span>hile(--v!==0);<span class="cstat-no" title="statement not covered" >a</span>=S}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(_[0]=-1,k=[],P=[],N=[],C=[],k[0]=9,P[0]=6,u=i,u=x.inflate_trees_dynamic(257+(u&amp;31),1+(u&gt;&gt;5&amp;31),o,k,P,N,C,m,f),u!=L)<span class="cstat-no" title="statement not covered" >return u==W&amp;&amp;(o=null,r=fe),c=u,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >d</span></span>.init(k[0],P[0],m,N[0],m,C[0]),r=Ie;c</span>ase Ie:<span class="cstat-no" title="statement not covered" >if(e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,(c=d.proc(e,f,c))!=z)<span class="cstat-no" title="statement not covered" >return e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >i</span></span>f(c=L,d.free(f),y=f.next_in_index,O=f.avail_in,h=e.bitb,w=e.bitk,b=e.write,A=b&lt;e.read?e.read-b-1:e.end-b,p===0){<span class="cstat-no" title="statement not covered" >r=he;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>=Ne;c</span>ase Ne:<span class="cstat-no" title="statement not covered" >if(e.write=b,c=e.inflate_flush(f,c),b=e.write,A=b&lt;e.read?e.read-b-1:e.end-b,e.read!=e.write)<span class="cstat-no" title="statement not covered" >return e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);<span class="cstat-no" title="statement not covered" >r</span></span>=qt;c</span>ase qt:<span class="cstat-no" title="statement not covered" >return c=z,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);c</span>ase fe:<span class="cstat-no" title="statement not covered" >return c=W,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c);d</span>efault:<span class="cstat-no" title="statement not covered" >return c=V,e.bitb=h,e.bitk=w,f.avail_in=O,f.total_in+=y-f.next_in_index,f.next_in_index=y,e.write=b,e.inflate_flush(f,c)}</span>}</span>}</span>,e.free=<span class="fstat-no" title="function not covered" >fu</span>nction(f){<span class="cstat-no" title="statement not covered" >e.reset(f,null),e.win=null,m=null}</span>,e.set_dictionary=<span class="fstat-no" title="function not covered" >fu</span>nction(f,c,u){<span class="cstat-no" title="statement not covered" >e.win.set(f.subarray(c,c+u),0),e.read=e.write=u}</span>,e.sync_point=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return r==Ge?1:0}</span>}</span>const as=<span class="cstat-no" title="statement not covered" >32,</span>os=<span class="cstat-no" title="statement not covered" >8,</span>cs=<span class="cstat-no" title="statement not covered" >0,</span>Gt=<span class="cstat-no" title="statement not covered" >1,</span>Yt=<span class="cstat-no" title="statement not covered" >2,</span>Vt=<span class="cstat-no" title="statement not covered" >3,</span>Zt=<span class="cstat-no" title="statement not covered" >4,</span>Kt=<span class="cstat-no" title="statement not covered" >5,</span>Ye=<span class="cstat-no" title="statement not covered" >6,</span>ye=<span class="cstat-no" title="statement not covered" >7,</span>Xt=<span class="cstat-no" title="statement not covered" >12,</span>ne=<span class="cstat-no" title="statement not covered" >13,</span>ls=<span class="cstat-no" title="statement not covered" >[0,0,255,255];</span>function <span class="fstat-no" title="function not covered" >fs(</span>){const n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>n.mode=0,n.method=0,n.was=[0],n.need=0,n.marker=0,n.wbits=0;f</span>unction <span class="fstat-no" title="function not covered" >t(</span>e){<span class="cstat-no" title="statement not covered" >return!e||!e.istate?V:(e.total_in=e.total_out=0,e.msg=null,e.istate.mode=ye,e.istate.blocks.reset(e,null),L)}<span class="cstat-no" title="statement not covered" ></span>n.inflateEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n.blocks&amp;&amp;n.blocks.free(e),n.blocks=null,L}</span>,n.inflateInit=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >return e.msg=null,n.blocks=null,r&lt;8||r&gt;15?(n.inflateEnd(e),V):(n.wbits=r,e.istate.blocks=new is(e,1&lt;&lt;r),t(e),L)}</span>,n.inflate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){let s,i;<span class="cstat-no" title="statement not covered" >if(!e||!e.istate||!e.next_in)<span class="cstat-no" title="statement not covered" >return V;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >e.istate;<span class="cstat-no" title="statement not covered" ></span>for(r=r==Xr?ee:L,s=ee;;)<span class="cstat-no" title="statement not covered" >switch(a.mode){case cs:<span class="cstat-no" title="statement not covered" >if(e.avail_in===0)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >i</span></span>f(s=r,e.avail_in--,e.total_in++,((a.method=e.read_byte(e.next_in_index++))&amp;15)!=os){<span class="cstat-no" title="statement not covered" >a.mode=ne,e.msg="unknown compression method",a.marker=5;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f((a.method&gt;&gt;4)+8&gt;a.wbits){<span class="cstat-no" title="statement not covered" >a.mode=ne,e.msg="invalid win size",a.marker=5;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>a</span>.mode=Gt;c</span>ase Gt:<span class="cstat-no" title="statement not covered" >if(e.avail_in===0)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >i</span></span>f(s=r,e.avail_in--,e.total_in++,i=e.read_byte(e.next_in_index++)&amp;255,((a.method&lt;&lt;8)+i)%31!==0){<span class="cstat-no" title="statement not covered" >a.mode=ne,e.msg="incorrect header check",a.marker=5;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(i&amp;as)){<span class="cstat-no" title="statement not covered" >a.mode=ye;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>a</span>.mode=Yt;c</span>ase Yt:<span class="cstat-no" title="statement not covered" >if(e.avail_in===0)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>=r,e.avail_in--,e.total_in++,a.need=(e.read_byte(e.next_in_index++)&amp;255)&lt;&lt;24&amp;4278190080,a.mode=Vt;c</span>ase Vt:<span class="cstat-no" title="statement not covered" >if(e.avail_in===0)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>=r,e.avail_in--,e.total_in++,a.need+=(e.read_byte(e.next_in_index++)&amp;255)&lt;&lt;16&amp;16711680,a.mode=Zt;c</span>ase Zt:<span class="cstat-no" title="statement not covered" >if(e.avail_in===0)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>=r,e.avail_in--,e.total_in++,a.need+=(e.read_byte(e.next_in_index++)&amp;255)&lt;&lt;8&amp;65280,a.mode=Kt;c</span>ase Kt:<span class="cstat-no" title="statement not covered" >return e.avail_in===0?s:(s=r,e.avail_in--,e.total_in++,a.need+=e.read_byte(e.next_in_index++)&amp;255,a.mode=Ye,Zr);c</span>ase Ye:<span class="cstat-no" title="statement not covered" >return a.mode=ne,e.msg="need dictionary",a.marker=0,V;c</span>ase ye:<span class="cstat-no" title="statement not covered" >if(s=a.blocks.proc(e,s),s==W){<span class="cstat-no" title="statement not covered" >a.mode=ne,a.marker=0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s==L&amp;&amp;(s=r),s!=z)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>=r,a.blocks.reset(e,a.was),a.mode=Xt;c</span>ase Xt:<span class="cstat-no" title="statement not covered" >return e.avail_in=0,z;c</span>ase ne:<span class="cstat-no" title="statement not covered" >return W;d</span>efault:<span class="cstat-no" title="statement not covered" >return V}</span>}</span></span>,n.inflateSetDictionary=<span class="fstat-no" title="function not covered" >fu</span>nction(e,r,s){let i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.istate||e.istate.mode!=Ye)<span class="cstat-no" title="statement not covered" >return V;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e.istate;<span class="cstat-no" title="statement not covered" ></span>return a&gt;=1&lt;&lt;o.wbits&amp;&amp;(a=(1&lt;&lt;o.wbits)-1,i=s-a),o.blocks.set_dictionary(r,i,a),o.mode=ye,L}</span>,n.inflateSync=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let r,s,i,a,o;<span class="cstat-no" title="statement not covered" >if(!e||!e.istate)<span class="cstat-no" title="statement not covered" >return V;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >e.istate;<span class="cstat-no" title="statement not covered" ></span>if(l.mode!=ne&amp;&amp;(l.mode=ne,l.marker=0),(r=e.avail_in)===0)<span class="cstat-no" title="statement not covered" >return ee;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=e.next_in_index,i=l.marker;r!==0&amp;&amp;i&lt;4;)<span class="cstat-no" title="statement not covered" >e.read_byte(s)==ls[i]?i++:e.read_byte(s)!==0?i=0:i=4-i,s++,r--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.total_in+=s-e.next_in_index,e.next_in_index=s,e.avail_in=r,l.marker=i,i!=4?W:(a=e.total_in,o=e.total_out,t(e),e.total_in=a,e.total_out=o,l.mode=ye,L)}</span>,n.inflateSyncPoint=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!e||!e.istate||!e.istate.blocks?V:e.istate.blocks.sync_point()}</span>}</span>function <span class="fstat-no" title="function not covered" >Sn(</span>){}<span class="cstat-no" title="statement not covered" >Sn.prototype={<span class="fstat-no" title="function not covered" >in</span>flateInit(n){const t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t.istate=new fs,n||(n=Vr),t.istate.inflateInit(t,n)}</span>,<span class="fstat-no" title="function not covered" >in</span>flate(n){const t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t.istate?t.istate.inflate(t,n):V}</span>,<span class="fstat-no" title="function not covered" >in</span>flateEnd(){const n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!n.istate)<span class="cstat-no" title="statement not covered" >return V;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >n.istate.inflateEnd(n);<span class="cstat-no" title="statement not covered" ></span>return n.istate=null,t}</span>,<span class="fstat-no" title="function not covered" >in</span>flateSync(){const n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return n.istate?n.istate.inflateSync(n):V}</span>,<span class="fstat-no" title="function not covered" >in</span>flateSetDictionary(n,t){const e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e.istate?e.istate.inflateSetDictionary(e,n,t):V}</span>,<span class="fstat-no" title="function not covered" >re</span>ad_byte(n){<span class="cstat-no" title="statement not covered" >return this.next_in[n]}</span>,<span class="fstat-no" title="function not covered" >re</span>ad_buf(n,t){<span class="cstat-no" title="statement not covered" >return this.next_in.subarray(n,n+t)}</span>};f</span>unction <span class="fstat-no" title="function not covered" >us(</span>n){const t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >new Sn,</span>r=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n.chunkSize?Math.floor(n.chunkSize*2):128*1024,</span>s=<span class="cstat-no" title="statement not covered" >Kr,</span>i=<span class="cstat-no" title="statement not covered" >new Uint8Array(r);</span>let a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>e.inflateInit(),e.next_out=i,t.append=<span class="fstat-no" title="function not covered" >fu</span>nction(o,l){const _=<span class="cstat-no" title="statement not covered" >[];</span>let d,p,m=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(o.length!==0){<span class="cstat-no" title="statement not covered" >e.next_in_index=0,e.next_in=o,e.avail_in=o.length;<span class="cstat-no" title="statement not covered" >d</span>o{<span class="cstat-no" title="statement not covered" >if(e.next_out_index=0,e.avail_out=r,e.avail_in===0&amp;&amp;!a&amp;&amp;(e.next_in_index=0,a=!0),d=e.inflate(s),a&amp;&amp;d===ee){<span class="cstat-no" title="statement not covered" >if(e.avail_in!==0)<span class="cstat-no" title="statement not covered" >throw new Error("inflating: bad input")}</span></span>else <span class="cstat-no" title="statement not covered" >if(d!==L&amp;&amp;d!==z)<span class="cstat-no" title="statement not covered" >throw new Error("inflating: "+e.msg);<span class="cstat-no" title="statement not covered" >i</span></span></span>f((a||d===z)&amp;&amp;e.avail_in===o.length)<span class="cstat-no" title="statement not covered" >throw new Error("inflating: bad input");<span class="cstat-no" title="statement not covered" >e</span></span>.next_out_index&amp;&amp;(e.next_out_index===r?_.push(new Uint8Array(i)):_.push(i.subarray(0,e.next_out_index))),x+=e.next_out_index,l&amp;&amp;e.next_in_index&gt;0&amp;&amp;e.next_in_index!=m&amp;&amp;(l(e.next_in_index),m=e.next_in_index)}</span>while(e.avail_in&gt;0||e.avail_out===0);<span class="cstat-no" title="statement not covered" >r</span>eturn _.length&gt;1?(p=new Uint8Array(x),_.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(f){<span class="cstat-no" title="statement not covered" >p.set(f,g),g+=f.length}</span>)):p=_[0]?new Uint8Array(_[0]):new Uint8Array,p}</span>}</span>,t.flush=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e.inflateEnd()}</span>}</span>const de=<span class="cstat-no" title="statement not covered" >4294967295,</span>ae=<span class="cstat-no" title="statement not covered" >65535,</span>ds=<span class="cstat-no" title="statement not covered" >8,</span>_s=<span class="cstat-no" title="statement not covered" >0,</span>hs=<span class="cstat-no" title="statement not covered" >99,</span>ps=<span class="cstat-no" title="statement not covered" >67324752,</span>ms=<span class="cstat-no" title="statement not covered" >134695760,</span>$t=<span class="cstat-no" title="statement not covered" >33639248,</span>ws=<span class="cstat-no" title="statement not covered" >101010256,</span>Jt=<span class="cstat-no" title="statement not covered" >101075792,</span>bs=<span class="cstat-no" title="statement not covered" >117853008,</span>pe=<span class="cstat-no" title="statement not covered" >22,</span>Ve=<span class="cstat-no" title="statement not covered" >20,</span>Ze=<span class="cstat-no" title="statement not covered" >56,</span>gs=<span class="cstat-no" title="statement not covered" >1,</span>ys=<span class="cstat-no" title="statement not covered" >39169,</span>xs=<span class="cstat-no" title="statement not covered" >10,</span>Es=<span class="cstat-no" title="statement not covered" >1,</span>Ts=<span class="cstat-no" title="statement not covered" >21589,</span>Ss=<span class="cstat-no" title="statement not covered" >28789,</span>As=<span class="cstat-no" title="statement not covered" >25461,</span>Rs=<span class="cstat-no" title="statement not covered" >6534,</span>Qt=<span class="cstat-no" title="statement not covered" >1,</span>Os=<span class="cstat-no" title="statement not covered" >6,</span>zt=<span class="cstat-no" title="statement not covered" >8,</span>en=<span class="cstat-no" title="statement not covered" >2048,</span>tn=<span class="cstat-no" title="statement not covered" >16,</span>ks=<span class="cstat-no" title="statement not covered" >"/",</span>$=<span class="cstat-no" title="statement not covered" >void 0,</span>Fe=<span class="cstat-no" title="statement not covered" >"undefined",</span>An=<span class="cstat-no" title="statement not covered" >"function";</span>class nn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >return class extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,r){const s=<span class="cstat-no" title="statement not covered" >new t(r);<span class="cstat-no" title="statement not covered" ></span>super({<span class="fstat-no" title="function not covered" >tr</span>ansform(i,a){<span class="cstat-no" title="statement not covered" >a.enqueue(s.append(i))}</span>,<span class="fstat-no" title="function not covered" >fl</span>ush(i){const a=<span class="cstat-no" title="statement not covered" >s.flush();<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;i.enqueue(a)}</span>})}</span>}}</span>}const Cs=<span class="cstat-no" title="statement not covered" >64;</span>let Rn=<span class="cstat-no" title="statement not covered" >2;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >typeof navigator!=Fe&amp;&amp;navigator.hardwareConcurrency&amp;&amp;(Rn=navigator.hardwareConcurrency)}</span>catch{}c</span>onst Ds=<span class="cstat-no" title="statement not covered" >{chunkSize:512*1024,maxWorkers:Rn,terminateWorkerTimeout:5e3,useWebWorkers:!0,useCompressionStream:!0,workerScripts:$,CompressionStreamNative:typeof CompressionStream!=Fe&amp;&amp;CompressionStream,DecompressionStreamNative:typeof DecompressionStream!=Fe&amp;&amp;DecompressionStream},</span>oe=<span class="cstat-no" title="statement not covered" >Object.assign({},Ds);</span>function <span class="fstat-no" title="function not covered" >On(</span>){<span class="cstat-no" title="statement not covered" >return oe}</span>function <span class="fstat-no" title="function not covered" >Is(</span>n){<span class="cstat-no" title="statement not covered" >return Math.max(n.chunkSize,Cs)}</span>function <span class="fstat-no" title="function not covered" >kn(</span>n){const{baseURL:t,chunkSize:e,maxWorkers:r,terminateWorkerTimeout:s,useCompressionStream:i,useWebWorkers:a,Deflate:o,Inflate:l,CompressionStream:_,DecompressionStream:d,workerScripts:p}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(re("baseURL",t),re("chunkSize",e),re("maxWorkers",r),re("terminateWorkerTimeout",s),re("useCompressionStream",i),re("useWebWorkers",a),o&amp;&amp;(oe.CompressionStream=new nn(o)),l&amp;&amp;(oe.DecompressionStream=new nn(l)),re("CompressionStream",_),re("DecompressionStream",d),p!==$){const{deflate:m,inflate:g}=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>if((m||g)&amp;&amp;(oe.workerScripts||(oe.workerScripts={})),m){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(m))<span class="cstat-no" title="statement not covered" >throw new Error("workerScripts.deflate must be an array");<span class="cstat-no" title="statement not covered" >o</span></span>e.workerScripts.deflate=m}<span class="cstat-no" title="statement not covered" ></span>i</span>f(g){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(g))<span class="cstat-no" title="statement not covered" >throw new Error("workerScripts.inflate must be an array");<span class="cstat-no" title="statement not covered" >o</span></span>e.workerScripts.inflate=g}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >re(</span>n,t){<span class="cstat-no" title="statement not covered" >t!==$&amp;&amp;(oe[n]=t)}</span>function <span class="fstat-no" title="function not covered" >Ns(</span>){<span class="cstat-no" title="statement not covered" >return"application/octet-stream"}</span>const Cn=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;256;n++){let t=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;8;e++)<span class="cstat-no" title="statement not covered" >t&amp;1?t=t&gt;&gt;&gt;1^3988292384:t=t&gt;&gt;&gt;1;<span class="cstat-no" title="statement not covered" >C</span></span>n[n]=t}</span>c</span>lass Ue{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.crc=t||-1}<span class="fstat-no" title="function not covered" ></span>ap</span>pend(t){let e=<span class="cstat-no" title="statement not covered" >this.crc|0;<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length|0;</span>r&lt;s;r++)<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;8^Cn[(e^t[r])&amp;255];<span class="cstat-no" title="statement not covered" >t</span></span>his.crc=e}<span class="fstat-no" title="function not covered" ></span>ge</span>t(){<span class="cstat-no" title="statement not covered" >return~this.crc}</span>}class Dn extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(){let t;const e=<span class="cstat-no" title="statement not covered" >new Ue;<span class="cstat-no" title="statement not covered" ></span>super({<span class="fstat-no" title="function not covered" >tr</span>ansform(r,s){<span class="cstat-no" title="statement not covered" >e.append(r),s.enqueue(r)}</span>,<span class="fstat-no" title="function not covered" >fl</span>ush(){const r=<span class="cstat-no" title="statement not covered" >new Uint8Array(4);<span class="cstat-no" title="statement not covered" ></span>new DataView(r.buffer).setUint32(0,e.get()),t.value=r}</span>}),t=this}</span>}function <span class="fstat-no" title="function not covered" >Ps(</span>n){<span class="cstat-no" title="statement not covered" >if(typeof TextEncoder&gt;"u"){<span class="cstat-no" title="statement not covered" >n=unescape(encodeURIComponent(n));c</span>onst t=<span class="cstat-no" title="statement not covered" >new Uint8Array(n.length);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >t[e]=n.charCodeAt(e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>else <span class="cstat-no" title="statement not covered" >return new TextEncoder().encode(n)}</span></span>const Y=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >co</span>ncat(n,t){<span class="cstat-no" title="statement not covered" >if(n.length===0||t.length===0)<span class="cstat-no" title="statement not covered" >return n.concat(t);c</span></span>onst e=<span class="cstat-no" title="statement not covered" >n[n.length-1],</span>r=<span class="cstat-no" title="statement not covered" >Y.getPartial(e);<span class="cstat-no" title="statement not covered" ></span>return r===32?n.concat(t):Y._shiftRight(t,r,e|0,n.slice(0,n.length-1))}</span>,<span class="fstat-no" title="function not covered" >bi</span>tLength(n){const t=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>if(t===0)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >n[t-1];<span class="cstat-no" title="statement not covered" ></span>return(t-1)*32+Y.getPartial(e)}</span>,<span class="fstat-no" title="function not covered" >cl</span>amp(n,t){<span class="cstat-no" title="statement not covered" >if(n.length*32&lt;t)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >n</span></span>=n.slice(0,Math.ceil(t/32));c</span>onst e=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>return t=t&amp;31,e&gt;0&amp;&amp;t&amp;&amp;(n[e-1]=Y.partial(t,n[e-1]&amp;2147483648&gt;&gt;t-1,1)),n}</span>,<span class="fstat-no" title="function not covered" >pa</span>rtial(n,t,e){<span class="cstat-no" title="statement not covered" >return n===32?t:(e?t|0:t&lt;&lt;32-n)+n*1099511627776}</span>,<span class="fstat-no" title="function not covered" >ge</span>tPartial(n){<span class="cstat-no" title="statement not covered" >return Math.round(n/1099511627776)||32}</span>,<span class="fstat-no" title="function not covered" >_s</span>hiftRight(n,t,e,r){<span class="cstat-no" title="statement not covered" >for(r===void 0&amp;&amp;(r=[]);t&gt;=32;t-=32)<span class="cstat-no" title="statement not covered" >r.push(e),e=0;<span class="cstat-no" title="statement not covered" >i</span></span>f(t===0)<span class="cstat-no" title="statement not covered" >return r.concat(n);<span class="cstat-no" title="statement not covered" >f</span></span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;n.length;a++)<span class="cstat-no" title="statement not covered" >r.push(e|n[a]&gt;&gt;&gt;t),e=n[a]&lt;&lt;32-t;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >n.length?n[n.length-1]:0,</span>i=<span class="cstat-no" title="statement not covered" >Y.getPartial(s);<span class="cstat-no" title="statement not covered" ></span>return r.push(Y.partial(t+i&amp;31,t+i&gt;32?e:r.pop(),1)),r}</span>},</span>Me=<span class="cstat-no" title="statement not covered" >{bytes:{<span class="fstat-no" title="function not covered" >fr</span>omBits(n){const e=<span class="cstat-no" title="statement not covered" >Y.bitLength(n)/8,</span>r=<span class="cstat-no" title="statement not covered" >new Uint8Array(e);</span>let s;<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e;i++)<span class="cstat-no" title="statement not covered" >i&amp;3||(s=n[i/4]),r[i]=s&gt;&gt;&gt;24,s&lt;&lt;=8;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,<span class="fstat-no" title="function not covered" >to</span>Bits(n){const t=<span class="cstat-no" title="statement not covered" >[];</span>let e,r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e=0;e&lt;n.length;e++)<span class="cstat-no" title="statement not covered" >r=r&lt;&lt;8|n[e],(e&amp;3)===3&amp;&amp;(t.push(r),r=0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e&amp;3&amp;&amp;t.push(Y.partial(8*(e&amp;3),r)),t}</span>}},</span>In=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>In.sha1=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(n){const t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.blockSize=512,t._init=[1732584193,4023233417,2562383102,271733878,3285377520],t._key=[1518500249,1859775393,2400959708,3395469782],n?(t._h=n._h.slice(0),t._buffer=n._buffer.slice(0),t._length=n._length):t.reset()}<span class="fstat-no" title="function not covered" ></span>re</span>set(){const n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return n._h=n._init.slice(0),n._buffer=[],n._length=0,n}<span class="fstat-no" title="function not covered" ></span>up</span>date(n){const t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>typeof n=="string"&amp;&amp;(n=Me.utf8String.toBits(n));c</span>onst e=<span class="cstat-no" title="statement not covered" >t._buffer=Y.concat(t._buffer,n),</span>r=<span class="cstat-no" title="statement not covered" >t._length,</span>s=<span class="cstat-no" title="statement not covered" >t._length=r+Y.bitLength(n);<span class="cstat-no" title="statement not covered" ></span>if(s&gt;9007199254740991)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot hash more than 2^53 - 1 bits");c</span></span>onst i=<span class="cstat-no" title="statement not covered" >new Uint32Array(e);</span>let a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >t.blockSize+r-(t.blockSize+r&amp;t.blockSize-1);</span>o&lt;=s;o+=t.blockSize)<span class="cstat-no" title="statement not covered" >t._block(i.subarray(16*a,16*(a+1))),a+=1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.splice(0,16*a),t}<span class="fstat-no" title="function not covered" ></span>fi</span>nalize(){const n=<span class="cstat-no" title="statement not covered" >this;</span>let t=<span class="cstat-no" title="statement not covered" >n._buffer;</span>const e=<span class="cstat-no" title="statement not covered" >n._h;<span class="cstat-no" title="statement not covered" ></span>t=Y.concat(t,[Y.partial(1,1)]);<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >t.length+2;</span>r&amp;15;r++)<span class="cstat-no" title="statement not covered" >t.push(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(t.push(Math.floor(n._length/4294967296)),t.push(n._length|0);t.length;)<span class="cstat-no" title="statement not covered" >n._block(t.splice(0,16));<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.reset(),e}<span class="fstat-no" title="function not covered" ></span>_f</span>(n,t,e,r){<span class="cstat-no" title="statement not covered" >if(n&lt;=19)<span class="cstat-no" title="statement not covered" >return t&amp;e|~t&amp;r;<span class="cstat-no" title="statement not covered" >i</span></span>f(n&lt;=39)<span class="cstat-no" title="statement not covered" >return t^e^r;<span class="cstat-no" title="statement not covered" >i</span></span>f(n&lt;=59)<span class="cstat-no" title="statement not covered" >return t&amp;e|t&amp;r|e&amp;r;<span class="cstat-no" title="statement not covered" >i</span></span>f(n&lt;=79)<span class="cstat-no" title="statement not covered" >return t^e^r}<span class="fstat-no" title="function not covered" ></span></span>_S</span>(n,t){<span class="cstat-no" title="statement not covered" >return t&lt;&lt;n|t&gt;&gt;&gt;32-n}<span class="fstat-no" title="function not covered" ></span>_b</span>lock(n){const t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >t._h,</span>r=<span class="cstat-no" title="statement not covered" >Array(80);<span class="cstat-no" title="statement not covered" ></span>for(let _=<span class="cstat-no" title="statement not covered" >0;</span>_&lt;16;_++)<span class="cstat-no" title="statement not covered" >r[_]=n[_];l</span></span>et s=<span class="cstat-no" title="statement not covered" >e[0],</span>i=<span class="cstat-no" title="statement not covered" >e[1],</span>a=<span class="cstat-no" title="statement not covered" >e[2],</span>o=<span class="cstat-no" title="statement not covered" >e[3],</span>l=<span class="cstat-no" title="statement not covered" >e[4];<span class="cstat-no" title="statement not covered" ></span>for(let _=<span class="cstat-no" title="statement not covered" >0;</span>_&lt;=79;_++){<span class="cstat-no" title="statement not covered" >_&gt;=16&amp;&amp;(r[_]=t._S(1,r[_-3]^r[_-8]^r[_-14]^r[_-16]));c</span>onst d=<span class="cstat-no" title="statement not covered" >t._S(5,s)+t._f(_,i,a,o)+l+r[_]+t._key[Math.floor(_/20)]|0;<span class="cstat-no" title="statement not covered" ></span>l=o,o=a,a=t._S(30,i),i=s,s=d}<span class="cstat-no" title="statement not covered" ></span>e</span>[0]=e[0]+s|0,e[1]=e[1]+i|0,e[2]=e[2]+a|0,e[3]=e[3]+o|0,e[4]=e[4]+l|0}</span>};c</span>onst Nn=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>Nn.aes=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(n){const t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],t._tables[0][0][0]||t._precompute();c</span>onst e=<span class="cstat-no" title="statement not covered" >t._tables[0][4],</span>r=<span class="cstat-no" title="statement not covered" >t._tables[1],</span>s=<span class="cstat-no" title="statement not covered" >n.length;</span>let i,a,o,l=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(s!==4&amp;&amp;s!==6&amp;&amp;s!==8)<span class="cstat-no" title="statement not covered" >throw new Error("invalid aes key size");<span class="cstat-no" title="statement not covered" >f</span></span>or(t._key=[a=n.slice(0),o=[]],i=s;i&lt;4*s+28;i++){let _=<span class="cstat-no" title="statement not covered" >a[i-1];<span class="cstat-no" title="statement not covered" ></span>(i%s===0||s===8&amp;&amp;i%s===4)&amp;&amp;(_=e[_&gt;&gt;&gt;24]&lt;&lt;24^e[_&gt;&gt;16&amp;255]&lt;&lt;16^e[_&gt;&gt;8&amp;255]&lt;&lt;8^e[_&amp;255],i%s===0&amp;&amp;(_=_&lt;&lt;8^_&gt;&gt;&gt;24^l&lt;&lt;24,l=l&lt;&lt;1^(l&gt;&gt;7)*283)),a[i]=a[i-s]^_}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let _=<span class="cstat-no" title="statement not covered" >0;</span>i;_++,i--){const d=<span class="cstat-no" title="statement not covered" >a[_&amp;3?i:i-4];<span class="cstat-no" title="statement not covered" ></span>i&lt;=4||_&lt;4?o[_]=d:o[_]=r[0][e[d&gt;&gt;&gt;24]]^r[1][e[d&gt;&gt;16&amp;255]]^r[2][e[d&gt;&gt;8&amp;255]]^r[3][e[d&amp;255]]}</span>}<span class="fstat-no" title="function not covered" ></span>en</span>crypt(n){<span class="cstat-no" title="statement not covered" >return this._crypt(n,0)}<span class="fstat-no" title="function not covered" ></span>de</span>crypt(n){<span class="cstat-no" title="statement not covered" >return this._crypt(n,1)}<span class="fstat-no" title="function not covered" ></span>_p</span>recompute(){const n=<span class="cstat-no" title="statement not covered" >this._tables[0],</span>t=<span class="cstat-no" title="statement not covered" >this._tables[1],</span>e=<span class="cstat-no" title="statement not covered" >n[4],</span>r=<span class="cstat-no" title="statement not covered" >t[4],</span>s=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let a,o,l,_;<span class="cstat-no" title="statement not covered" >for(let d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;256;d++)<span class="cstat-no" title="statement not covered" >i[(s[d]=d&lt;&lt;1^(d&gt;&gt;7)*283)^d]=d;<span class="cstat-no" title="statement not covered" >f</span></span>or(let d=<span class="cstat-no" title="statement not covered" >a=0;</span>!e[d];d^=o||1,a=i[a]||1){let p=<span class="cstat-no" title="statement not covered" >a^a&lt;&lt;1^a&lt;&lt;2^a&lt;&lt;3^a&lt;&lt;4;<span class="cstat-no" title="statement not covered" ></span>p=p&gt;&gt;8^p&amp;255^99,e[d]=p,r[p]=d,_=s[l=s[o=s[d]]];l</span>et m=<span class="cstat-no" title="statement not covered" >_*16843009^l*65537^o*257^d*16843008,</span>g=<span class="cstat-no" title="statement not covered" >s[p]*257^p*16843008;<span class="cstat-no" title="statement not covered" ></span>for(let x=<span class="cstat-no" title="statement not covered" >0;</span>x&lt;4;x++)<span class="cstat-no" title="statement not covered" >n[x][d]=g=g&lt;&lt;24^g&gt;&gt;&gt;8,t[x][p]=m=m&lt;&lt;24^m&gt;&gt;&gt;8}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(let d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;5;d++)<span class="cstat-no" title="statement not covered" >n[d]=n[d].slice(0),t[d]=t[d].slice(0)}<span class="fstat-no" title="function not covered" ></span></span>_c</span>rypt(n,t){<span class="cstat-no" title="statement not covered" >if(n.length!==4)<span class="cstat-no" title="statement not covered" >throw new Error("invalid aes block size");c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._key[t],</span>r=<span class="cstat-no" title="statement not covered" >e.length/4-2,</span>s=<span class="cstat-no" title="statement not covered" >[0,0,0,0],</span>i=<span class="cstat-no" title="statement not covered" >this._tables[t],</span>a=<span class="cstat-no" title="statement not covered" >i[0],</span>o=<span class="cstat-no" title="statement not covered" >i[1],</span>l=<span class="cstat-no" title="statement not covered" >i[2],</span>_=<span class="cstat-no" title="statement not covered" >i[3],</span>d=<span class="cstat-no" title="statement not covered" >i[4];</span>let p=<span class="cstat-no" title="statement not covered" >n[0]^e[0],</span>m=<span class="cstat-no" title="statement not covered" >n[t?3:1]^e[1],</span>g=<span class="cstat-no" title="statement not covered" >n[2]^e[2],</span>x=<span class="cstat-no" title="statement not covered" >n[t?1:3]^e[3],</span>f=<span class="cstat-no" title="statement not covered" >4,</span>c,u,h;<span class="cstat-no" title="statement not covered" >for(let w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;r;w++)<span class="cstat-no" title="statement not covered" >c=a[p&gt;&gt;&gt;24]^o[m&gt;&gt;16&amp;255]^l[g&gt;&gt;8&amp;255]^_[x&amp;255]^e[f],u=a[m&gt;&gt;&gt;24]^o[g&gt;&gt;16&amp;255]^l[x&gt;&gt;8&amp;255]^_[p&amp;255]^e[f+1],h=a[g&gt;&gt;&gt;24]^o[x&gt;&gt;16&amp;255]^l[p&gt;&gt;8&amp;255]^_[m&amp;255]^e[f+2],x=a[x&gt;&gt;&gt;24]^o[p&gt;&gt;16&amp;255]^l[m&gt;&gt;8&amp;255]^_[g&amp;255]^e[f+3],f+=4,p=c,m=u,g=h;<span class="cstat-no" title="statement not covered" >f</span></span>or(let w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;4;w++)<span class="cstat-no" title="statement not covered" >s[t?3&amp;-w:w]=d[p&gt;&gt;&gt;24]&lt;&lt;24^d[m&gt;&gt;16&amp;255]&lt;&lt;16^d[g&gt;&gt;8&amp;255]&lt;&lt;8^d[x&amp;255]^e[f++],c=p,p=m,m=g,g=x,x=c;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>};c</span>onst Ls=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ge</span>tRandomValues(n){const t=<span class="cstat-no" title="statement not covered" >new Uint32Array(n.buffer),</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >987654321;</span>const i=<span class="cstat-no" title="statement not covered" >4294967295;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s=36969*(s&amp;65535)+(s&gt;&gt;16)&amp;i,r=18e3*(r&amp;65535)+(r&gt;&gt;16)&amp;i,(((s&lt;&lt;16)+r&amp;i)/4294967296+.5)*(Math.random()&gt;.5?1:-1)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0,</span>s;r&lt;n.length;r+=4){const i=<span class="cstat-no" title="statement not covered" >e((s||Math.random())*4294967296);<span class="cstat-no" title="statement not covered" ></span>s=i()*987654071,t[r/4]=i()*4294967296|0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>},</span>Pn=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>Pn.ctrGladman=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(n,t){<span class="cstat-no" title="statement not covered" >this._prf=n,this._initIv=t,this._iv=t}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._iv=this._initIv}<span class="fstat-no" title="function not covered" ></span>up</span>date(n){<span class="cstat-no" title="statement not covered" >return this.calculate(this._prf,n,this._iv)}<span class="fstat-no" title="function not covered" ></span>in</span>cWord(n){<span class="cstat-no" title="statement not covered" >if((n&gt;&gt;24&amp;255)===255){let t=<span class="cstat-no" title="statement not covered" >n&gt;&gt;16&amp;255,</span>e=<span class="cstat-no" title="statement not covered" >n&gt;&gt;8&amp;255,</span>r=<span class="cstat-no" title="statement not covered" >n&amp;255;<span class="cstat-no" title="statement not covered" ></span>t===255?(t=0,e===255?(e=0,r===255?r=0:++r):++e):++t,n=0,n+=t&lt;&lt;16,n+=e&lt;&lt;8,n+=r}</span>else <span class="cstat-no" title="statement not covered" >n+=1&lt;&lt;24;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>in</span>cCounter(n){<span class="cstat-no" title="statement not covered" >(n[0]=this.incWord(n[0]))===0&amp;&amp;(n[1]=this.incWord(n[1]))}<span class="fstat-no" title="function not covered" ></span>ca</span>lculate(n,t,e){let r;<span class="cstat-no" title="statement not covered" >if(!(r=t.length))<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst s=<span class="cstat-no" title="statement not covered" >Y.bitLength(t);<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r;i+=4){<span class="cstat-no" title="statement not covered" >this.incCounter(e);c</span>onst a=<span class="cstat-no" title="statement not covered" >n.encrypt(e);<span class="cstat-no" title="statement not covered" ></span>t[i]^=a[0],t[i+1]^=a[1],t[i+2]^=a[2],t[i+3]^=a[3]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Y.clamp(t,s)}</span>};c</span>onst _e=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >im</span>portKey(n){<span class="cstat-no" title="statement not covered" >return new _e.hmacSha1(Me.bytes.toBits(n))}</span>,<span class="fstat-no" title="function not covered" >pb</span>kdf2(n,t,e,r){<span class="cstat-no" title="statement not covered" >if(e=e||1e4,r&lt;0||e&lt;0)<span class="cstat-no" title="statement not covered" >throw new Error("invalid params to pbkdf2");c</span></span>onst s=<span class="cstat-no" title="statement not covered" >(r&gt;&gt;5)+1&lt;&lt;2;</span>let i,a,o,l,_;const d=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(s),</span>p=<span class="cstat-no" title="statement not covered" >new DataView(d);</span>let m=<span class="cstat-no" title="statement not covered" >0;</span>const g=<span class="cstat-no" title="statement not covered" >Y;<span class="cstat-no" title="statement not covered" ></span>for(t=Me.bytes.toBits(t),_=1;m&lt;(s||1);_++){<span class="cstat-no" title="statement not covered" >for(i=a=n.encrypt(g.concat(t,[_])),o=1;o&lt;e;o++)<span class="cstat-no" title="statement not covered" >for(a=n.encrypt(a),l=0;l&lt;a.length;l++)<span class="cstat-no" title="statement not covered" >i[l]^=a[l];<span class="cstat-no" title="statement not covered" >f</span></span></span>or(o=0;m&lt;(s||1)&amp;&amp;o&lt;i.length;o++)<span class="cstat-no" title="statement not covered" >p.setInt32(m,i[o]),m+=4}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn d.slice(0,r/8)}</span>};<span class="cstat-no" title="statement not covered" ></span>_e.hmacSha1=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(n){const t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >t._hash=In.sha1,</span>r=<span class="cstat-no" title="statement not covered" >[[],[]];<span class="cstat-no" title="statement not covered" ></span>t._baseHash=[new e,new e];c</span>onst s=<span class="cstat-no" title="statement not covered" >t._baseHash[0].blockSize/32;<span class="cstat-no" title="statement not covered" ></span>n.length&gt;s&amp;&amp;(n=new e().update(n).finalize());<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;s;i++)<span class="cstat-no" title="statement not covered" >r[0][i]=n[i]^909522486,r[1][i]=n[i]^1549556828;<span class="cstat-no" title="statement not covered" >t</span></span>._baseHash[0].update(r[0]),t._baseHash[1].update(r[1]),t._resultHash=new e(t._baseHash[0])}<span class="fstat-no" title="function not covered" ></span>re</span>set(){const n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>n._resultHash=new n._hash(n._baseHash[0]),n._updated=!1}<span class="fstat-no" title="function not covered" ></span>up</span>date(n){const t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t._updated=!0,t._resultHash.update(n)}<span class="fstat-no" title="function not covered" ></span>di</span>gest(){const n=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >n._resultHash.finalize(),</span>e=<span class="cstat-no" title="statement not covered" >new n._hash(n._baseHash[1]).update(t).finalize();<span class="cstat-no" title="statement not covered" ></span>return n.reset(),e}<span class="fstat-no" title="function not covered" ></span>en</span>crypt(n){<span class="cstat-no" title="statement not covered" >if(this._updated)<span class="cstat-no" title="statement not covered" >throw new Error("encrypt on already updated hmac called!");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.update(n),this.digest(n)}</span>};c</span>onst Fs=<span class="cstat-no" title="statement not covered" >typeof crypto&lt;"u"&amp;&amp;typeof crypto.getRandomValues=="function",</span>dt=<span class="cstat-no" title="statement not covered" >"Invalid password",</span>_t=<span class="cstat-no" title="statement not covered" >"Invalid signature",</span>ht=<span class="cstat-no" title="statement not covered" >"zipjs-abort-check-password";</span>function <span class="fstat-no" title="function not covered" >Ln(</span>n){<span class="cstat-no" title="statement not covered" >return Fs?crypto.getRandomValues(n):Ls.getRandomValues(n)}</span>const me=<span class="cstat-no" title="statement not covered" >16,</span>Us=<span class="cstat-no" title="statement not covered" >"raw",</span>Fn=<span class="cstat-no" title="statement not covered" >{name:"PBKDF2"},</span>Ms=<span class="cstat-no" title="statement not covered" >{name:"HMAC"},</span>vs=<span class="cstat-no" title="statement not covered" >"SHA-1",</span>Hs=<span class="cstat-no" title="statement not covered" >Object.assign({hash:Ms},Fn),</span>tt=<span class="cstat-no" title="statement not covered" >Object.assign({iterations:1e3,hash:{name:vs}},Fn),</span>Ws=<span class="cstat-no" title="statement not covered" >["deriveBits"],</span>Te=<span class="cstat-no" title="statement not covered" >[8,12,16],</span>xe=<span class="cstat-no" title="statement not covered" >[16,24,32],</span>se=<span class="cstat-no" title="statement not covered" >10,</span>Bs=<span class="cstat-no" title="statement not covered" >[0,0,0,0],</span>Un=<span class="cstat-no" title="statement not covered" >"undefined",</span>Mn=<span class="cstat-no" title="statement not covered" >"function",</span>We=<span class="cstat-no" title="statement not covered" >typeof crypto!=Un,</span>Oe=<span class="cstat-no" title="statement not covered" >We&amp;&amp;crypto.subtle,</span>vn=<span class="cstat-no" title="statement not covered" >We&amp;&amp;typeof Oe!=Un,</span>J=<span class="cstat-no" title="statement not covered" >Me.bytes,</span>js=<span class="cstat-no" title="statement not covered" >Nn.aes,</span>qs=<span class="cstat-no" title="statement not covered" >Pn.ctrGladman,</span>Gs=<span class="cstat-no" title="statement not covered" >_e.hmacSha1;</span>let rn=<span class="cstat-no" title="statement not covered" >We&amp;&amp;vn&amp;&amp;typeof Oe.importKey==Mn,</span>sn=<span class="cstat-no" title="statement not covered" >We&amp;&amp;vn&amp;&amp;typeof Oe.deriveBits==Mn;</span>class Ys extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor({password:t,signed:e,encryptionStrength:r,checkPasswordOnly:s}){<span class="cstat-no" title="statement not covered" >super({<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >Object.assign(this,{ready:new Promise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >this.resolveReady=i)</span>,password:t,signed:e,strength:r-1,pending:new Uint8Array})}</span>,<span class="fstat-no" title="function not covered" >as</span>ync transform(i,a){const o=<span class="cstat-no" title="statement not covered" >this,</span>{password:l,strength:_,resolveReady:d,ready:p}=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>l?(await Zs(o,_,l,X(i,0,Te[_]+2)),i=X(i,Te[_]+2),s?a.error(new Error(ht)):d()):await p;c</span>onst m=<span class="cstat-no" title="statement not covered" >new Uint8Array(i.length-se-(i.length-se)%me);<span class="cstat-no" title="statement not covered" ></span>a.enqueue(Hn(o,i,m,0,se,!0))}</span>,<span class="fstat-no" title="function not covered" >as</span>ync flush(i){const{signed:a,ctr:o,hmac:l,pending:_,ready:d}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;o){<span class="cstat-no" title="statement not covered" >await d;c</span>onst p=<span class="cstat-no" title="statement not covered" >X(_,0,_.length-se),</span>m=<span class="cstat-no" title="statement not covered" >X(_,_.length-se);</span>let g=<span class="cstat-no" title="statement not covered" >new Uint8Array;<span class="cstat-no" title="statement not covered" ></span>if(p.length){const x=<span class="cstat-no" title="statement not covered" >Ae(J,p);<span class="cstat-no" title="statement not covered" ></span>l.update(x);c</span>onst f=<span class="cstat-no" title="statement not covered" >o.update(x);<span class="cstat-no" title="statement not covered" ></span>g=Se(J,f)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a){const x=<span class="cstat-no" title="statement not covered" >X(Se(J,l.digest()),0,se);<span class="cstat-no" title="statement not covered" ></span>for(let f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;se;f++)<span class="cstat-no" title="statement not covered" >if(x[f]!=m[f])<span class="cstat-no" title="statement not covered" >throw new Error(_t)}<span class="cstat-no" title="statement not covered" ></span></span></span>i</span>.enqueue(g)}</span>}</span>})}</span>}class Vs extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor({password:t,encryptionStrength:e}){let r;<span class="cstat-no" title="statement not covered" >super({<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >Object.assign(this,{ready:new Promise(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >this.resolveReady=s)</span>,password:t,strength:e-1,pending:new Uint8Array})}</span>,<span class="fstat-no" title="function not covered" >as</span>ync transform(s,i){const a=<span class="cstat-no" title="statement not covered" >this,</span>{password:o,strength:l,resolveReady:_,ready:d}=<span class="cstat-no" title="statement not covered" >a;</span>let p=<span class="cstat-no" title="statement not covered" >new Uint8Array;<span class="cstat-no" title="statement not covered" ></span>o?(p=await Ks(a,l,o),_()):await d;c</span>onst m=<span class="cstat-no" title="statement not covered" >new Uint8Array(p.length+s.length-s.length%me);<span class="cstat-no" title="statement not covered" ></span>m.set(p,0),i.enqueue(Hn(a,s,m,p.length,0))}</span>,<span class="fstat-no" title="function not covered" >as</span>ync flush(s){const{ctr:i,hmac:a,pending:o,ready:l}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;i){<span class="cstat-no" title="statement not covered" >await l;l</span>et _=<span class="cstat-no" title="statement not covered" >new Uint8Array;<span class="cstat-no" title="statement not covered" ></span>if(o.length){const d=<span class="cstat-no" title="statement not covered" >i.update(Ae(J,o));<span class="cstat-no" title="statement not covered" ></span>a.update(d),_=Se(J,d)}<span class="cstat-no" title="statement not covered" ></span>r</span>.signature=Se(J,a.digest()).slice(0,se),s.enqueue(pt(_,r.signature))}</span>}</span>}),r=this}</span>}function <span class="fstat-no" title="function not covered" >Hn(</span>n,t,e,r,s,i){const{ctr:a,hmac:o,pending:l}=<span class="cstat-no" title="statement not covered" >n,</span>_=<span class="cstat-no" title="statement not covered" >t.length-s;<span class="cstat-no" title="statement not covered" ></span>l.length&amp;&amp;(t=pt(l,t),e=Js(e,_-_%me));l</span>et d;<span class="cstat-no" title="statement not covered" >for(d=0;d&lt;=_-me;d+=me){const p=<span class="cstat-no" title="statement not covered" >Ae(J,X(t,d,d+me));<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;o.update(p);c</span>onst m=<span class="cstat-no" title="statement not covered" >a.update(p);<span class="cstat-no" title="statement not covered" ></span>i||o.update(m),e.set(Se(J,m),d+r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.pending=X(t,d),e}</span>async function <span class="fstat-no" title="function not covered" >Zs(</span>n,t,e,r){const s=<span class="cstat-no" title="statement not covered" >await Wn(n,t,e,X(r,0,Te[t])),</span>i=<span class="cstat-no" title="statement not covered" >X(r,Te[t]);<span class="cstat-no" title="statement not covered" ></span>if(s[0]!=i[0]||s[1]!=i[1])<span class="cstat-no" title="statement not covered" >throw new Error(dt)}</span></span>async function <span class="fstat-no" title="function not covered" >Ks(</span>n,t,e){const r=<span class="cstat-no" title="statement not covered" >Ln(new Uint8Array(Te[t])),</span>s=<span class="cstat-no" title="statement not covered" >await Wn(n,t,e,r);<span class="cstat-no" title="statement not covered" ></span>return pt(r,s)}</span>async function <span class="fstat-no" title="function not covered" >Wn(</span>n,t,e,r){<span class="cstat-no" title="statement not covered" >n.password=null;c</span>onst s=<span class="cstat-no" title="statement not covered" >Ps(e),</span>i=<span class="cstat-no" title="statement not covered" >await Xs(Us,s,Hs,!1,Ws),</span>a=<span class="cstat-no" title="statement not covered" >await $s(Object.assign({salt:r},tt),i,8*(xe[t]*2+2)),</span>o=<span class="cstat-no" title="statement not covered" >new Uint8Array(a),</span>l=<span class="cstat-no" title="statement not covered" >Ae(J,X(o,0,xe[t])),</span>_=<span class="cstat-no" title="statement not covered" >Ae(J,X(o,xe[t],xe[t]*2)),</span>d=<span class="cstat-no" title="statement not covered" >X(o,xe[t]*2);<span class="cstat-no" title="statement not covered" ></span>return Object.assign(n,{keys:{key:l,authentication:_,passwordVerification:d},ctr:new qs(new js(l),Array.from(Bs)),hmac:new Gs(_)}),d}</span>async function <span class="fstat-no" title="function not covered" >Xs(</span>n,t,e,r,s){<span class="cstat-no" title="statement not covered" >if(rn)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await Oe.importKey(n,t,e,r,s)}</span>catch{<span class="cstat-no" title="statement not covered" >return rn=!1,_e.importKey(t)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >return _e.importKey(t)}</span></span>async function <span class="fstat-no" title="function not covered" >$s(</span>n,t,e){<span class="cstat-no" title="statement not covered" >if(sn)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await Oe.deriveBits(n,t,e)}</span>catch{<span class="cstat-no" title="statement not covered" >return sn=!1,_e.pbkdf2(t,n.salt,tt.iterations,e)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >return _e.pbkdf2(t,n.salt,tt.iterations,e)}</span></span>function <span class="fstat-no" title="function not covered" >pt(</span>n,t){let e=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>return n.length+t.length&amp;&amp;(e=new Uint8Array(n.length+t.length),e.set(n,0),e.set(t,n.length)),e}</span>function <span class="fstat-no" title="function not covered" >Js(</span>n,t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;t&gt;n.length){const e=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=new Uint8Array(t),n.set(e,0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >X(</span>n,t,e){<span class="cstat-no" title="statement not covered" >return n.subarray(t,e)}</span>function <span class="fstat-no" title="function not covered" >Se(</span>n,t){<span class="cstat-no" title="statement not covered" >return n.fromBits(t)}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>n,t){<span class="cstat-no" title="statement not covered" >return n.toBits(t)}</span>const we=<span class="cstat-no" title="statement not covered" >12;</span>class Qs extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor({password:t,passwordVerification:e,checkPasswordOnly:r}){<span class="cstat-no" title="statement not covered" >super({<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >Object.assign(this,{password:t,passwordVerification:e}),Bn(this,t)}</span>,<span class="fstat-no" title="function not covered" >tr</span>ansform(s,i){const a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(a.password){const o=<span class="cstat-no" title="statement not covered" >an(a,s.subarray(0,we));<span class="cstat-no" title="statement not covered" ></span>if(a.password=null,o[we-1]!=a.passwordVerification)<span class="cstat-no" title="statement not covered" >throw new Error(dt);<span class="cstat-no" title="statement not covered" >s</span></span>=s.subarray(we)}<span class="cstat-no" title="statement not covered" ></span>r</span>?i.error(new Error(ht)):i.enqueue(an(a,s))}</span>})}</span>}class zs extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor({password:t,passwordVerification:e}){<span class="cstat-no" title="statement not covered" >super({<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >Object.assign(this,{password:t,passwordVerification:e}),Bn(this,t)}</span>,<span class="fstat-no" title="function not covered" >tr</span>ansform(r,s){const i=<span class="cstat-no" title="statement not covered" >this;</span>let a,o;<span class="cstat-no" title="statement not covered" >if(i.password){<span class="cstat-no" title="statement not covered" >i.password=null;c</span>onst l=<span class="cstat-no" title="statement not covered" >Ln(new Uint8Array(we));<span class="cstat-no" title="statement not covered" ></span>l[we-1]=i.passwordVerification,a=new Uint8Array(r.length+l.length),a.set(on(i,l),0),o=we}</span>else <span class="cstat-no" title="statement not covered" >a=new Uint8Array(r.length),o=0;<span class="cstat-no" title="statement not covered" >a</span></span>.set(on(i,r),o),s.enqueue(a)}</span>})}</span>}function <span class="fstat-no" title="function not covered" >an(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >new Uint8Array(t.length);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >e[r]=jn(n)^t[r],mt(n,e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >on(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >new Uint8Array(t.length);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >e[r]=jn(n)^t[r],mt(n,t[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Bn(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >[305419896,591751049,878082192];<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,{keys:e,crcKey0:new Ue(e[0]),crcKey2:new Ue(e[2])});<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >mt(n,t.charCodeAt(r))}</span></span>function <span class="fstat-no" title="function not covered" >mt(</span>n,t){let[e,r,s]=<span class="cstat-no" title="statement not covered" >n.keys;<span class="cstat-no" title="statement not covered" ></span>n.crcKey0.append([t]),e=~n.crcKey0.get(),r=cn(Math.imul(cn(r+qn(e)),134775813)+1),n.crcKey2.append([r&gt;&gt;&gt;24]),s=~n.crcKey2.get(),n.keys=[e,r,s]}</span>function <span class="fstat-no" title="function not covered" >jn(</span>n){const t=<span class="cstat-no" title="statement not covered" >n.keys[2]|2;<span class="cstat-no" title="statement not covered" ></span>return qn(Math.imul(t,t^1)&gt;&gt;&gt;8)}</span>function <span class="fstat-no" title="function not covered" >qn(</span>n){<span class="cstat-no" title="statement not covered" >return n&amp;255}</span>function <span class="fstat-no" title="function not covered" >cn(</span>n){<span class="cstat-no" title="statement not covered" >return n&amp;4294967295}</span>const ln=<span class="cstat-no" title="statement not covered" >"deflate-raw";</span>class ei extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{chunkSize:e,CompressionStream:r,CompressionStreamNative:s}){<span class="cstat-no" title="statement not covered" >super({});c</span>onst{compressed:i,encrypted:a,useCompressionStream:o,zipCrypto:l,signed:_,level:d}=<span class="cstat-no" title="statement not covered" >t,</span>p=<span class="cstat-no" title="statement not covered" >this;</span>let m,g,x=<span class="cstat-no" title="statement not covered" >Gn(super.readable);<span class="cstat-no" title="statement not covered" ></span>(!a||l)&amp;&amp;_&amp;&amp;(m=new Dn,x=Q(x,m)),i&amp;&amp;(x=Vn(x,o,{level:d,chunkSize:e},s,r)),a&amp;&amp;(l?x=Q(x,new zs(t)):(g=new Vs(t),x=Q(x,g))),Yn(p,x,<span class="fstat-no" title="function not covered" >()</span>=&gt;{let f;<span class="cstat-no" title="statement not covered" >a&amp;&amp;!l&amp;&amp;(f=g.signature),(!a||l)&amp;&amp;_&amp;&amp;(f=new DataView(m.value.buffer).getUint32(0)),p.signature=f}</span>)}</span>}class ti extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{chunkSize:e,DecompressionStream:r,DecompressionStreamNative:s}){<span class="cstat-no" title="statement not covered" >super({});c</span>onst{zipCrypto:i,encrypted:a,signed:o,signature:l,compressed:_,useCompressionStream:d}=<span class="cstat-no" title="statement not covered" >t;</span>let p,m,g=<span class="cstat-no" title="statement not covered" >Gn(super.readable);<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(i?g=Q(g,new Qs(t)):(m=new Ys(t),g=Q(g,m))),_&amp;&amp;(g=Vn(g,d,{chunkSize:e},s,r)),(!a||i)&amp;&amp;o&amp;&amp;(p=new Dn,g=Q(g,p)),Yn(this,g,<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if((!a||i)&amp;&amp;o){const x=<span class="cstat-no" title="statement not covered" >new DataView(p.value.buffer);<span class="cstat-no" title="statement not covered" ></span>if(l!=x.getUint32(0,!1))<span class="cstat-no" title="statement not covered" >throw new Error(_t)}</span></span>}</span>)}</span>}function <span class="fstat-no" title="function not covered" >Gn(</span>n){<span class="cstat-no" title="statement not covered" >return Q(n,new TransformStream({<span class="fstat-no" title="function not covered" >tr</span>ansform(t,e){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.length&amp;&amp;e.enqueue(t)}</span>}))}</span>function <span class="fstat-no" title="function not covered" >Yn(</span>n,t,e){<span class="cstat-no" title="statement not covered" >t=Q(t,new TransformStream({flush:e})),Object.defineProperty(n,"readable",{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return t}</span>})}</span>function <span class="fstat-no" title="function not covered" >Vn(</span>n,t,e,r,s){<span class="cstat-no" title="statement not covered" >try{const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;r?r:s;<span class="cstat-no" title="statement not covered" ></span>n=Q(n,new i(ln,e))}</span>catch(i){<span class="cstat-no" title="statement not covered" >if(t)<span class="cstat-no" title="statement not covered" >n=Q(n,new s(ln,e));e</span>lse <span class="cstat-no" title="statement not covered" >throw i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >Q(</span>n,t){<span class="cstat-no" title="statement not covered" >return n.pipeThrough(t)}</span>const ni=<span class="cstat-no" title="statement not covered" >"message",</span>ri=<span class="cstat-no" title="statement not covered" >"start",</span>si=<span class="cstat-no" title="statement not covered" >"pull",</span>fn=<span class="cstat-no" title="statement not covered" >"data",</span>ii=<span class="cstat-no" title="statement not covered" >"ack",</span>ai=<span class="cstat-no" title="statement not covered" >"close",</span>oi=<span class="cstat-no" title="statement not covered" >"deflate",</span>Zn=<span class="cstat-no" title="statement not covered" >"inflate";</span>class ci extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super({});c</span>onst r=<span class="cstat-no" title="statement not covered" >this,</span>{codecType:s}=<span class="cstat-no" title="statement not covered" >t;</span>let i;<span class="cstat-no" title="statement not covered" >s.startsWith(oi)?i=ei:s.startsWith(Zn)&amp;&amp;(i=ti);l</span>et a=<span class="cstat-no" title="statement not covered" >0;</span>const o=<span class="cstat-no" title="statement not covered" >new i(t,e),</span>l=<span class="cstat-no" title="statement not covered" >super.readable,</span>_=<span class="cstat-no" title="statement not covered" >new TransformStream({<span class="fstat-no" title="function not covered" >tr</span>ansform(d,p){<span class="cstat-no" title="statement not covered" >d&amp;&amp;d.length&amp;&amp;(a+=d.length,p.enqueue(d))}</span>,<span class="fstat-no" title="function not covered" >fl</span>ush(){const{signature:d}=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>Object.assign(r,{signature:d,size:a})}</span>});<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(r,"readable",{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return l.pipeThrough(o).pipeThrough(_)}</span>})}</span>}const li=<span class="cstat-no" title="statement not covered" >typeof Worker!=Fe;</span>class Ke{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{readable:e,writable:r},{options:s,config:i,streamOptions:a,useWebWorkers:o,transferStreams:l,scripts:_},d){const{signal:p}=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>return Object.assign(t,{busy:!0,readable:e.pipeThrough(new fi(e,a,i),{signal:p}),writable:r,options:Object.assign({},s),scripts:_,transferStreams:l,<span class="fstat-no" title="function not covered" >te</span>rminate(){const{worker:m,busy:g}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>m&amp;&amp;!g&amp;&amp;(m.terminate(),t.interface=null)}</span>,<span class="fstat-no" title="function not covered" >on</span>TaskFinished(){<span class="cstat-no" title="statement not covered" >t.busy=!1,d(t)}</span>}),(o&amp;&amp;li?di:ui)(t,i)}</span>}class fi extends TransformStream{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{onstart:e,onprogress:r,size:s,onend:i},{chunkSize:a}){let o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>super({<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >e&amp;&amp;Xe(e,s)}</span>,<span class="fstat-no" title="function not covered" >as</span>ync transform(l,_){<span class="cstat-no" title="statement not covered" >o+=l.length,r&amp;&amp;await Xe(r,o,s),_.enqueue(l)}</span>,<span class="fstat-no" title="function not covered" >fl</span>ush(){<span class="cstat-no" title="statement not covered" >t.size=o,i&amp;&amp;Xe(i,o)}</span>},{highWaterMark:1,size:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a}</span>)}</span>}async function <span class="fstat-no" title="function not covered" >Xe(</span>n,...t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await n(...t)}</span>catch{}}</span>function <span class="fstat-no" title="function not covered" >ui(</span>n,t){<span class="cstat-no" title="statement not covered" >return{run:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_i(n,t)}</span>}</span>function <span class="fstat-no" title="function not covered" >di(</span>n,{baseURL:t,chunkSize:e}){<span class="cstat-no" title="statement not covered" >return n.interface||Object.assign(n,{worker:mi(n.scripts[0],t,n),interface:{run:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >hi(n,{chunkSize:e})}</span>}),n.interface}</span>async function <span class="fstat-no" title="function not covered" >_i(</span>{options:n,readable:t,writable:e,onTaskFinished:r},s){const i=<span class="cstat-no" title="statement not covered" >new ci(n,s);<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >await t.pipeThrough(i).pipeTo(e,{preventClose:!0,preventAbort:!0});c</span>onst{signature:a,size:o}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>return{signature:a,size:o}}</span>finally{<span class="cstat-no" title="statement not covered" >r()}</span>}</span>async function <span class="fstat-no" title="function not covered" >hi(</span>n,t){let e,r;const s=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >(m</span>,g)=&gt;{<span class="cstat-no" title="statement not covered" >e=m,r=g}</span>);<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,{reader:null,writer:null,resolveResult:e,rejectResult:r,result:s});c</span>onst{readable:i,options:a,scripts:o}=<span class="cstat-no" title="statement not covered" >n,</span>{writable:l,closed:_}=<span class="cstat-no" title="statement not covered" >pi(n.writable);<span class="cstat-no" title="statement not covered" ></span>nt({type:ri,scripts:o.slice(1),options:a,config:t,readable:i,writable:l},n)||Object.assign(n,{reader:i.getReader(),writer:l.getWriter()});c</span>onst p=<span class="cstat-no" title="statement not covered" >await s;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >await l.getWriter().close()}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn await _,p}</span>function <span class="fstat-no" title="function not covered" >pi(</span>n){const t=<span class="cstat-no" title="statement not covered" >n.getWriter();</span>let e;const r=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >e=i)</span>;<span class="cstat-no" title="statement not covered" ></span>return{writable:new WritableStream({<span class="fstat-no" title="function not covered" >as</span>ync write(i){<span class="cstat-no" title="statement not covered" >await t.ready,await t.write(i)}</span>,<span class="fstat-no" title="function not covered" >cl</span>ose(){<span class="cstat-no" title="statement not covered" >t.releaseLock(),e()}</span>,<span class="fstat-no" title="function not covered" >ab</span>ort(i){<span class="cstat-no" title="statement not covered" >return t.abort(i)}</span>}),closed:r}}</span>let un=<span class="cstat-no" title="statement not covered" >!0,</span>dn=<span class="cstat-no" title="statement not covered" >!0;</span>function <span class="fstat-no" title="function not covered" >mi(</span>n,t,e){const r=<span class="cstat-no" title="statement not covered" >{type:"module"};</span>let s,i;<span class="cstat-no" title="statement not covered" >typeof n==An&amp;&amp;(n=n());<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >s=new URL(n,t)}</span>catch{<span class="cstat-no" title="statement not covered" >s=n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(un)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=new Worker(s)}</span>catch{<span class="cstat-no" title="statement not covered" >un=!1,i=new Worker(s,r)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >i=new Worker(s,r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i.addEventListener(ni,<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >wi(a,e))</span>,i}</span>function <span class="fstat-no" title="function not covered" >nt(</span>n,{worker:t,writer:e,onTaskFinished:r,transferStreams:s}){<span class="cstat-no" title="statement not covered" >try{let{value:i,readable:a,writable:o}=<span class="cstat-no" title="statement not covered" >n;</span>const l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;(i.byteLength&lt;i.buffer.byteLength?n.value=i.buffer.slice(0,i.byteLength):n.value=i.buffer,l.push(n.value)),s&amp;&amp;dn?(a&amp;&amp;l.push(a),o&amp;&amp;l.push(o)):n.readable=n.writable=null,l.length)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return t.postMessage(n,l),!0}</span>catch{<span class="cstat-no" title="statement not covered" >dn=!1,n.readable=n.writable=null,t.postMessage(n)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >t.postMessage(n)}</span></span>catch(i){<span class="cstat-no" title="statement not covered" >throw e&amp;&amp;e.releaseLock(),r(),i}</span>}</span>async function <span class="fstat-no" title="function not covered" >wi(</span>{data:n},t){const{type:e,value:r,messageId:s,result:i,error:a}=<span class="cstat-no" title="statement not covered" >n,</span>{reader:o,writer:l,resolveResult:_,rejectResult:d,onTaskFinished:p}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >if(a){const{message:g,stack:x,code:f,name:c}=<span class="cstat-no" title="statement not covered" >a,</span>u=<span class="cstat-no" title="statement not covered" >new Error(g);<span class="cstat-no" title="statement not covered" ></span>Object.assign(u,{stack:x,code:f,name:c}),m(u)}</span>else{<span class="cstat-no" title="statement not covered" >if(e==si){const{value:g,done:x}=<span class="cstat-no" title="statement not covered" >await o.read();<span class="cstat-no" title="statement not covered" ></span>nt({type:fn,value:g,done:x,messageId:s},t)}<span class="cstat-no" title="statement not covered" ></span>e</span>==fn&amp;&amp;(await l.ready,await l.write(new Uint8Array(r)),nt({type:ii,messageId:s},t)),e==ai&amp;&amp;m(null,i)}</span>}</span>catch(g){<span class="cstat-no" title="statement not covered" >m(g)}</span>f</span>unction <span class="fstat-no" title="function not covered" >m(</span>g,x){<span class="cstat-no" title="statement not covered" >g?d(g):_(x),l&amp;&amp;l.releaseLock(),p()}</span>}let ie=<span class="cstat-no" title="statement not covered" >[];</span>const $e=<span class="cstat-no" title="statement not covered" >[];</span>let _n=<span class="cstat-no" title="statement not covered" >0;</span>async function <span class="fstat-no" title="function not covered" >bi(</span>n,t){const{options:e,config:r}=<span class="cstat-no" title="statement not covered" >t,</span>{transferStreams:s,useWebWorkers:i,useCompressionStream:a,codecType:o,compressed:l,signed:_,encrypted:d}=<span class="cstat-no" title="statement not covered" >e,</span>{workerScripts:p,maxWorkers:m,terminateWorkerTimeout:g}=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>t.transferStreams=s||s===$;c</span>onst x=<span class="cstat-no" title="statement not covered" >!l&amp;&amp;!_&amp;&amp;!d&amp;&amp;!t.transferStreams;<span class="cstat-no" title="statement not covered" ></span>t.useWebWorkers=!x&amp;&amp;(i||i===$&amp;&amp;r.useWebWorkers),t.scripts=t.useWebWorkers&amp;&amp;p?p[o]:[],e.useCompressionStream=a||a===$&amp;&amp;r.useCompressionStream;l</span>et f;const c=<span class="cstat-no" title="statement not covered" >ie.find(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >!h.busy)</span>;<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >rt(c),f=new Ke(c,n,t,u);e</span>lse <span class="cstat-no" title="statement not covered" >if(ie.length&lt;m){const h=<span class="cstat-no" title="statement not covered" >{indexWorker:_n};<span class="cstat-no" title="statement not covered" ></span>_n++,ie.push(h),f=new Ke(h,n,t,u)}</span>else <span class="cstat-no" title="statement not covered" >f=await new Promise(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >$e.push({resolve:h,stream:n,workerOptions:t}))</span>;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn f.run();f</span>unction <span class="fstat-no" title="function not covered" >u(</span>h){<span class="cstat-no" title="statement not covered" >if($e.length){const[{resolve:w,stream:y,workerOptions:O}]=<span class="cstat-no" title="statement not covered" >$e.splice(0,1);<span class="cstat-no" title="statement not covered" ></span>w(new Ke(h,y,O,u))}</span>else <span class="cstat-no" title="statement not covered" >h.worker?(rt(h),Number.isFinite(g)&amp;&amp;g&gt;=0&amp;&amp;(h.terminateTimeout=setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >ie=ie.filter(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >w!=h)</span>,h.terminate()}</span>,g))):ie=ie.filter(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >w!=h)</span>}</span></span>}function <span class="fstat-no" title="function not covered" >rt(</span>n){const{terminateTimeout:t}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(clearTimeout(t),n.terminateTimeout=null)}</span>function <span class="fstat-no" title="function not covered" >gi(</span>){<span class="cstat-no" title="statement not covered" >ie.forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >rt(n),n.terminate()}</span>)}</span>const Kn=<span class="cstat-no" title="statement not covered" >"HTTP error ",</span>ke=<span class="cstat-no" title="statement not covered" >"HTTP Range not supported",</span>Xn=<span class="cstat-no" title="statement not covered" >"Writer iterator completed too soon",</span>yi=<span class="cstat-no" title="statement not covered" >"text/plain",</span>xi=<span class="cstat-no" title="statement not covered" >"Content-Length",</span>Ei=<span class="cstat-no" title="statement not covered" >"Content-Range",</span>Ti=<span class="cstat-no" title="statement not covered" >"Accept-Ranges",</span>Si=<span class="cstat-no" title="statement not covered" >"Range",</span>Ai=<span class="cstat-no" title="statement not covered" >"Content-Type",</span>Ri=<span class="cstat-no" title="statement not covered" >"HEAD",</span>wt=<span class="cstat-no" title="statement not covered" >"GET",</span>$n=<span class="cstat-no" title="statement not covered" >"bytes",</span>Oi=<span class="cstat-no" title="statement not covered" >64*1024,</span>bt=<span class="cstat-no" title="statement not covered" >"writable";</span>class Be{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.size=0}<span class="fstat-no" title="function not covered" ></span>in</span>it(){<span class="cstat-no" title="statement not covered" >this.initialized=!0}</span>}class ce extends Be{<span class="fstat-no" title="function not covered" >ge</span>t readable(){const t=<span class="cstat-no" title="statement not covered" >this,</span>{chunkSize:e=<span class="branch-0 cbranch-no" title="branch not covered" >Oi}</span>=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >new ReadableStream({<span class="fstat-no" title="function not covered" >st</span>art(){<span class="cstat-no" title="statement not covered" >this.chunkOffset=0}</span>,<span class="fstat-no" title="function not covered" >as</span>ync pull(s){const{offset:i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>size:a,diskNumberStart:o}=<span class="cstat-no" title="statement not covered" >r,</span>{chunkOffset:l}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>s.enqueue(await G(t,i+l,Math.min(e,a-l),o)),l+e&gt;a?s.close():this.chunkOffset+=e}</span>});<span class="cstat-no" title="statement not covered" ></span>return r}</span>}class gt extends Be{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super();c</span>onst t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >new WritableStream({<span class="fstat-no" title="function not covered" >wr</span>ite(r){<span class="cstat-no" title="statement not covered" >return t.writeUint8Array(r)}</span>});<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,bt,{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return e}</span>})}<span class="fstat-no" title="function not covered" ></span>wr</span>iteUint8Array(){}}class ki extends ce{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();l</span>et e=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(;t.charAt(e-1)=="=";)<span class="cstat-no" title="statement not covered" >e--;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >t.indexOf(",")+1;<span class="cstat-no" title="statement not covered" ></span>Object.assign(this,{dataURI:t,dataStart:r,size:Math.floor((e-r)*.75)})}<span class="fstat-no" title="function not covered" ></span>re</span>adUint8Array(t,e){const{dataStart:r,dataURI:s}=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >new Uint8Array(e),</span>a=<span class="cstat-no" title="statement not covered" >Math.floor(t/3)*4,</span>o=<span class="cstat-no" title="statement not covered" >atob(s.substring(a+r,Math.ceil((t+e)/3)*4+r)),</span>l=<span class="cstat-no" title="statement not covered" >t-Math.floor(a/4)*3;<span class="cstat-no" title="statement not covered" ></span>for(let _=<span class="cstat-no" title="statement not covered" >l;</span>_&lt;l+e;_++)<span class="cstat-no" title="statement not covered" >i[_-l]=o.charCodeAt(_);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>}class Ci extends gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),Object.assign(this,{data:"data:"+(t||"")+";base64,",pending:[]})}<span class="fstat-no" title="function not covered" ></span>wr</span>iteUint8Array(t){const e=<span class="cstat-no" title="statement not covered" >this;</span>let r=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e.pending;</span>const i=<span class="cstat-no" title="statement not covered" >e.pending.length;<span class="cstat-no" title="statement not covered" ></span>for(e.pending="",r=0;r&lt;Math.floor((i+t.length)/3)*3-i;r++)<span class="cstat-no" title="statement not covered" >s+=String.fromCharCode(t[r]);<span class="cstat-no" title="statement not covered" >f</span></span>or(;r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >e.pending+=String.fromCharCode(t[r]);<span class="cstat-no" title="statement not covered" >s</span></span>.length&gt;2?e.data+=btoa(s):e.pending=s}<span class="fstat-no" title="function not covered" ></span>ge</span>tData(){<span class="cstat-no" title="statement not covered" >return this.data+btoa(this.pending)}</span>}class yt extends ce{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),Object.assign(this,{blob:t,size:t.size})}<span class="fstat-no" title="function not covered" ></span>as</span>ync readUint8Array(t,e){const r=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >t+e;</span>let a=<span class="cstat-no" title="statement not covered" >await(t||s&lt;r.size?r.blob.slice(t,s):r.blob).arrayBuffer();<span class="cstat-no" title="statement not covered" ></span>return a.byteLength&gt;e&amp;&amp;(a=a.slice(t,s)),new Uint8Array(a)}</span>}class Jn extends Be{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super();c</span>onst e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >new TransformStream,</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;s.push([Ai,t]),Object.defineProperty(e,bt,{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return r.writable}</span>}),e.blob=new Response(r.readable,{headers:s}).blob()}<span class="fstat-no" title="function not covered" ></span>ge</span>tData(){<span class="cstat-no" title="statement not covered" >return this.blob}</span>}class Di extends yt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(new Blob([t],{type:yi}))}</span>}class Ii extends Jn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),Object.assign(this,{encoding:t,utf8:!t||t.toLowerCase()=="utf-8"})}<span class="fstat-no" title="function not covered" ></span>as</span>ync getData(){const{encoding:t,utf8:e}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >await super.getData();<span class="cstat-no" title="statement not covered" ></span>if(r.text&amp;&amp;e)<span class="cstat-no" title="statement not covered" >return r.text();{</span></span>const s=<span class="cstat-no" title="statement not covered" >new FileReader;<span class="cstat-no" title="statement not covered" ></span>return new Promise(<span class="fstat-no" title="function not covered" >(i</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >Object.assign(s,{onload:<span class="fstat-no" title="function not covered" >({</span>target:o})=&gt;<span class="cstat-no" title="statement not covered" >i(o.result),</span>onerror:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a(s.error)}</span>),s.readAsText(r,t)}</span>)}</span>}}class Ni extends ce{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(),Qn(this,t,e)}<span class="fstat-no" title="function not covered" ></span>as</span>ync init(){<span class="cstat-no" title="statement not covered" >await zn(this,st,hn),super.init()}<span class="fstat-no" title="function not covered" ></span>re</span>adUint8Array(t,e){<span class="cstat-no" title="statement not covered" >return er(this,t,e,st,hn)}</span>}class Pi extends ce{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(),Qn(this,t,e)}<span class="fstat-no" title="function not covered" ></span>as</span>ync init(){<span class="cstat-no" title="statement not covered" >await zn(this,it,pn),super.init()}<span class="fstat-no" title="function not covered" ></span>re</span>adUint8Array(t,e){<span class="cstat-no" title="statement not covered" >return er(this,t,e,it,pn)}</span>}function <span class="fstat-no" title="function not covered" >Qn(</span>n,t,e){const{preventHeadRequest:r,useRangeHeader:s,forceRangeRequests:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>e=Object.assign({},e),delete e.preventHeadRequest,delete e.useRangeHeader,delete e.forceRangeRequests,delete e.useXHR,Object.assign(n,{url:t,options:e,preventHeadRequest:r,useRangeHeader:s,forceRangeRequests:i})}</span>async function <span class="fstat-no" title="function not covered" >zn(</span>n,t,e){const{url:r,useRangeHeader:s,forceRangeRequests:i}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(Mi(r)&amp;&amp;(s||i)){const{headers:a}=<span class="cstat-no" title="statement not covered" >await t(wt,n,tr(n));<span class="cstat-no" title="statement not covered" ></span>if(!i&amp;&amp;a.get(Ti)!=$n)<span class="cstat-no" title="statement not covered" >throw new Error(ke);{</span></span>let o;const l=<span class="cstat-no" title="statement not covered" >a.get(Ei);<span class="cstat-no" title="statement not covered" ></span>if(l){const _=<span class="cstat-no" title="statement not covered" >l.trim().split(/\s*\/\s*/);<span class="cstat-no" title="statement not covered" ></span>if(_.length){const d=<span class="cstat-no" title="statement not covered" >_[1];<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;d!="*"&amp;&amp;(o=Number(d))}</span>}<span class="cstat-no" title="statement not covered" ></span>o</span>===$?await mn(n,t,e):n.size=o}</span>}else <span class="cstat-no" title="statement not covered" >await mn(n,t,e)}</span></span>async function <span class="fstat-no" title="function not covered" >er(</span>n,t,e,r,s){const{useRangeHeader:i,forceRangeRequests:a,options:o}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(i||a){const l=<span class="cstat-no" title="statement not covered" >await r(wt,n,tr(n,t,e));<span class="cstat-no" title="statement not covered" ></span>if(l.status!=206)<span class="cstat-no" title="statement not covered" >throw new Error(ke);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Uint8Array(await l.arrayBuffer())}</span>else{const{data:l}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>return l||await s(n,o),new Uint8Array(n.data.subarray(t,t+e))}</span>}</span>function <span class="fstat-no" title="function not covered" >tr(</span>n,t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >return Object.assign({},xt(n),{[Si]:$n+"="+t+"-"+(t+e-1)})}</span>function <span class="fstat-no" title="function not covered" >xt(</span>{options:n}){const{headers:t}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return Symbol.iterator in t?Object.fromEntries(t):t}</span></span>async function <span class="fstat-no" title="function not covered" >hn(</span>n){<span class="cstat-no" title="statement not covered" >await nr(n,st)}</span>async function <span class="fstat-no" title="function not covered" >pn(</span>n){<span class="cstat-no" title="statement not covered" >await nr(n,it)}</span>async function <span class="fstat-no" title="function not covered" >nr(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >await t(wt,n,xt(n));<span class="cstat-no" title="statement not covered" ></span>n.data=new Uint8Array(await e.arrayBuffer()),n.size||(n.size=n.data.length)}</span>async function <span class="fstat-no" title="function not covered" >mn(</span>n,t,e){<span class="cstat-no" title="statement not covered" >if(n.preventHeadRequest)<span class="cstat-no" title="statement not covered" >await e(n,n.options);e</span>lse{const s=<span class="cstat-no" title="statement not covered" >(await t(Ri,n,xt(n))).headers.get(xi);<span class="cstat-no" title="statement not covered" ></span>s?n.size=Number(s):await e(n,n.options)}</span>}</span>async function <span class="fstat-no" title="function not covered" >st(</span>n,{options:t,url:e},r){const s=<span class="cstat-no" title="statement not covered" >await fetch(e,Object.assign({},t,{method:n,headers:r}));<span class="cstat-no" title="statement not covered" ></span>if(s.status&lt;400)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >t</span></span>hrow s.status==416?new Error(ke):new Error(Kn+(s.statusText||s.status))}</span>function <span class="fstat-no" title="function not covered" >it(</span>n,{url:t},e){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;{const i=<span class="cstat-no" title="statement not covered" >new XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>if(i.addEventListener("load",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(i.status&lt;400){const a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach(<span class="fstat-no" title="function not covered" >o=</span>&gt;{const l=<span class="cstat-no" title="statement not covered" >o.trim().split(/\s*:\s*/);<span class="cstat-no" title="statement not covered" ></span>l[0]=l[0].trim().replace(/^[a-z]|-[a-z]/g,<span class="fstat-no" title="function not covered" >_=</span>&gt;<span class="cstat-no" title="statement not covered" >_.toUpperCase())</span>,a.push(l)}</span>),r({status:i.status,arrayBuffer:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i.response,</span>headers:new Map(a)})}</span>else <span class="cstat-no" title="statement not covered" >s(i.status==416?new Error(ke):new Error(Kn+(i.statusText||i.status)))}</span></span>,!1),i.addEventListener("error",<span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >s(a.detail?a.detail.error:new Error("Network error")),</span>!1),i.open(n,t),e)<span class="cstat-no" title="statement not covered" >for(const a of Object.entries(e))<span class="cstat-no" title="statement not covered" >i.setRequestHeader(a[0],a[1]);<span class="cstat-no" title="statement not covered" >i</span></span></span>.responseType="arraybuffer",i.send()}</span>)}</span>class rr extends ce{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >super(),Object.assign(this,{url:t,reader:e.useXHR?new Pi(t,e):new Ni(t,e)})}<span class="fstat-no" title="function not covered" ></span>se</span>t size(t){}<span class="fstat-no" title="function not covered" >ge</span>t size(){<span class="cstat-no" title="statement not covered" >return this.reader.size}<span class="fstat-no" title="function not covered" ></span>as</span>ync init(){<span class="cstat-no" title="statement not covered" >await this.reader.init(),super.init()}<span class="fstat-no" title="function not covered" ></span>re</span>adUint8Array(t,e){<span class="cstat-no" title="statement not covered" >return this.reader.readUint8Array(t,e)}</span>}class Li extends rr{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >e.useRangeHeader=!0,super(t,e)}</span>}class Fi extends ce{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),Object.assign(this,{array:t,size:t.length})}<span class="fstat-no" title="function not covered" ></span>re</span>adUint8Array(t,e){<span class="cstat-no" title="statement not covered" >return this.array.slice(t,t+e)}</span>}class Ui extends gt{<span class="fstat-no" title="function not covered" >in</span>it(t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >Object.assign(this,{offset:0,array:new Uint8Array(t)}),super.init()}<span class="fstat-no" title="function not covered" ></span>wr</span>iteUint8Array(t){const e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(e.offset+t.length&gt;e.array.length){const r=<span class="cstat-no" title="statement not covered" >e.array;<span class="cstat-no" title="statement not covered" ></span>e.array=new Uint8Array(r.length+t.length),e.array.set(r)}<span class="cstat-no" title="statement not covered" ></span>e</span>.array.set(t,e.offset),e.offset+=t.length}<span class="fstat-no" title="function not covered" ></span>ge</span>tData(){<span class="cstat-no" title="statement not covered" >return this.array}</span>}class Et extends ce{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.readers=t}<span class="fstat-no" title="function not covered" ></span>as</span>ync init(){const t=<span class="cstat-no" title="statement not covered" >this,</span>{readers:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>t.lastDiskNumber=0,t.lastDiskOffset=0,await Promise.all(e.map(<span class="fstat-no" title="function not covered" >as</span>ync(r,s)=&gt;{<span class="cstat-no" title="statement not covered" >await r.init(),s!=e.length-1&amp;&amp;(t.lastDiskOffset+=r.size),t.size+=r.size}</span>)),super.init()}<span class="fstat-no" title="function not covered" ></span>as</span>ync readUint8Array(t,e,r=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{const s=<span class="cstat-no" title="statement not covered" >this,</span>{readers:i}=<span class="cstat-no" title="statement not covered" >this;</span>let a,o=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>o==-1&amp;&amp;(o=i.length-1);l</span>et l=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(;l&gt;=i[o].size;)<span class="cstat-no" title="statement not covered" >l-=i[o].size,o++;c</span></span>onst _=<span class="cstat-no" title="statement not covered" >i[o],</span>d=<span class="cstat-no" title="statement not covered" >_.size;<span class="cstat-no" title="statement not covered" ></span>if(l+e&lt;=d)<span class="cstat-no" title="statement not covered" >a=await G(_,l,e);e</span>lse{const p=<span class="cstat-no" title="statement not covered" >d-l;<span class="cstat-no" title="statement not covered" ></span>a=new Uint8Array(e),a.set(await G(_,l,p)),a.set(await s.readUint8Array(t+p,e-p,r),p)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.lastDiskNumber=Math.max(o,s.lastDiskNumber),a}</span>}class ve extends Be{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >4294967295)</span>{<span class="cstat-no" title="statement not covered" >super();c</span>onst r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>Object.assign(r,{diskNumber:0,diskOffset:0,size:0,maxSize:e,availableSize:e});l</span>et s,i,a;const o=<span class="cstat-no" title="statement not covered" >new WritableStream({<span class="fstat-no" title="function not covered" >as</span>ync write(d){const{availableSize:p}=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >d.length&gt;=p?(await l(d.slice(0,p)),await _(),r.diskOffset+=s.size,r.diskNumber++,a=null,await this.write(d.slice(p))):await l(d);e</span>lse{const{value:m,done:g}=<span class="cstat-no" title="statement not covered" >await t.next();<span class="cstat-no" title="statement not covered" ></span>if(g&amp;&amp;!m)<span class="cstat-no" title="statement not covered" >throw new Error(Xn);<span class="cstat-no" title="statement not covered" >s</span></span>=m,s.size=0,s.maxSize&amp;&amp;(r.maxSize=s.maxSize),r.availableSize=r.maxSize,await Re(s),i=m.writable,a=i.getWriter(),await this.write(d)}</span>}</span>,<span class="fstat-no" title="function not covered" >as</span>ync close(){<span class="cstat-no" title="statement not covered" >await a.ready,await _()}</span>});<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(r,bt,{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return o}</span>});a</span>sync function <span class="fstat-no" title="function not covered" >l(</span>d){const p=<span class="cstat-no" title="statement not covered" >d.length;<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(await a.ready,await a.write(d),s.size+=p,r.size+=p,r.availableSize-=p)}</span>async function <span class="fstat-no" title="function not covered" >_(</span>){<span class="cstat-no" title="statement not covered" >i.size=s.size,await a.close()}</span>}}function <span class="fstat-no" title="function not covered" >Mi(</span>n){const{baseURL:t}=<span class="cstat-no" title="statement not covered" >On(),</span>{protocol:e}=<span class="cstat-no" title="statement not covered" >new URL(n,t);<span class="cstat-no" title="statement not covered" ></span>return e=="http:"||e=="https:"}</span>async function <span class="fstat-no" title="function not covered" >Re(</span>n,t){<span class="cstat-no" title="statement not covered" >n.init&amp;&amp;!n.initialized&amp;&amp;await n.init(t)}</span>function <span class="fstat-no" title="function not covered" >sr(</span>n){<span class="cstat-no" title="statement not covered" >return Array.isArray(n)&amp;&amp;(n=new Et(n)),n instanceof ReadableStream&amp;&amp;(n={readable:n}),n}</span>function <span class="fstat-no" title="function not covered" >ir(</span>n){<span class="cstat-no" title="statement not covered" >n.writable===$&amp;&amp;typeof n.next==An&amp;&amp;(n=new ve(n)),n instanceof WritableStream&amp;&amp;(n={writable:n});c</span>onst{writable:t}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>return t.size===$&amp;&amp;(t.size=0),n instanceof ve||Object.assign(n,{diskNumber:0,diskOffset:0,availableSize:1/0,maxSize:1/0}),n}</span>function <span class="fstat-no" title="function not covered" >G(</span>n,t,e,r){<span class="cstat-no" title="statement not covered" >return n.readUint8Array(t,e,r)}</span>const vi=<span class="cstat-no" title="statement not covered" >Et,</span>Hi=<span class="cstat-no" title="statement not covered" >ve,</span>ar=<span class="cstat-no" title="statement not covered" >"\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split(""),</span>Wi=<span class="cstat-no" title="statement not covered" >ar.length==256;</span>function <span class="fstat-no" title="function not covered" >Bi(</span>n){<span class="cstat-no" title="statement not covered" >if(Wi){let t=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;n.length;e++)<span class="cstat-no" title="statement not covered" >t+=ar[n[e]];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>else <span class="cstat-no" title="statement not covered" >return new TextDecoder().decode(n)}</span></span>function <span class="fstat-no" title="function not covered" >at(</span>n,t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t.trim().toLowerCase()=="cp437"?Bi(n):new TextDecoder(t).decode(n)}</span>const or=<span class="cstat-no" title="statement not covered" >"filename",</span>cr=<span class="cstat-no" title="statement not covered" >"rawFilename",</span>lr=<span class="cstat-no" title="statement not covered" >"comment",</span>fr=<span class="cstat-no" title="statement not covered" >"rawComment",</span>ur=<span class="cstat-no" title="statement not covered" >"uncompressedSize",</span>dr=<span class="cstat-no" title="statement not covered" >"compressedSize",</span>_r=<span class="cstat-no" title="statement not covered" >"offset",</span>ot=<span class="cstat-no" title="statement not covered" >"diskNumberStart",</span>ct=<span class="cstat-no" title="statement not covered" >"lastModDate",</span>lt=<span class="cstat-no" title="statement not covered" >"rawLastModDate",</span>hr=<span class="cstat-no" title="statement not covered" >"lastAccessDate",</span>ji=<span class="cstat-no" title="statement not covered" >"rawLastAccessDate",</span>pr=<span class="cstat-no" title="statement not covered" >"creationDate",</span>qi=<span class="cstat-no" title="statement not covered" >"rawCreationDate",</span>Gi=<span class="cstat-no" title="statement not covered" >"internalFileAttribute",</span>Yi=<span class="cstat-no" title="statement not covered" >"externalFileAttribute",</span>Vi=<span class="cstat-no" title="statement not covered" >"msDosCompatible",</span>Zi=<span class="cstat-no" title="statement not covered" >"zip64",</span>Ki=<span class="cstat-no" title="statement not covered" >[or,cr,dr,ur,ct,lt,lr,fr,hr,pr,_r,ot,ot,Gi,Yi,Vi,Zi,"directory","bitFlag","encrypted","signature","filenameUTF8","commentUTF8","compressionMethod","version","versionMadeBy","extraField","rawExtraField","extraFieldZip64","extraFieldUnicodePath","extraFieldUnicodeComment","extraFieldAES","extraFieldNTFS","extraFieldExtendedTimestamp"];</span>class wn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >Ki.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this[e]=t[e])</span>}</span>}const Pe=<span class="cstat-no" title="statement not covered" >"File format is not recognized",</span>mr=<span class="cstat-no" title="statement not covered" >"End of central directory not found",</span>wr=<span class="cstat-no" title="statement not covered" >"End of Zip64 central directory not found",</span>br=<span class="cstat-no" title="statement not covered" >"End of Zip64 central directory locator not found",</span>gr=<span class="cstat-no" title="statement not covered" >"Central directory header not found",</span>yr=<span class="cstat-no" title="statement not covered" >"Local file header not found",</span>xr=<span class="cstat-no" title="statement not covered" >"Zip64 extra field not found",</span>Er=<span class="cstat-no" title="statement not covered" >"File contains encrypted entry",</span>Tr=<span class="cstat-no" title="statement not covered" >"Encryption method not supported",</span>ft=<span class="cstat-no" title="statement not covered" >"Compression method not supported",</span>ut=<span class="cstat-no" title="statement not covered" >"Split zip file",</span>bn=<span class="cstat-no" title="statement not covered" >"utf-8",</span>gn=<span class="cstat-no" title="statement not covered" >"cp437",</span>Xi=<span class="cstat-no" title="statement not covered" >[[ur,de],[dr,de],[_r,de],[ot,ae]],</span>$i=<span class="cstat-no" title="statement not covered" >{[ae]:{getValue:B,bytes:4},[de]:{getValue:Le,bytes:8}};</span>class Ji{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >Object.assign(this,{reader:sr(t),options:e,config:On()})}<span class="fstat-no" title="function not covered" ></span>as</span>ync*getEntriesGenerator(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >this;</span>let{reader:r}=<span class="cstat-no" title="statement not covered" >e;</span>const{config:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(await Re(r),(r.size===$||!r.readUint8Array)&amp;&amp;(r=new yt(await new Response(r.readable).blob()),await Re(r)),r.size&lt;pe)<span class="cstat-no" title="statement not covered" >throw new Error(Pe);<span class="cstat-no" title="statement not covered" >r</span></span>.chunkSize=Is(s);c</span>onst i=<span class="cstat-no" title="statement not covered" >await ra(r,ws,r.size,pe,ae*16);<span class="cstat-no" title="statement not covered" ></span>if(!i){const E=<span class="cstat-no" title="statement not covered" >await G(r,0,4),</span>T=<span class="cstat-no" title="statement not covered" >q(E);<span class="cstat-no" title="statement not covered" ></span>throw B(T)==ms?new Error(ut):new Error(mr)}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >q(i);</span>let o=<span class="cstat-no" title="statement not covered" >B(a,12),</span>l=<span class="cstat-no" title="statement not covered" >B(a,16);</span>const _=<span class="cstat-no" title="statement not covered" >i.offset,</span>d=<span class="cstat-no" title="statement not covered" >j(a,20),</span>p=<span class="cstat-no" title="statement not covered" >_+pe+d;</span>let m=<span class="cstat-no" title="statement not covered" >j(a,4);</span>const g=<span class="cstat-no" title="statement not covered" >r.lastDiskNumber||0;</span>let x=<span class="cstat-no" title="statement not covered" >j(a,6),</span>f=<span class="cstat-no" title="statement not covered" >j(a,8),</span>c=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(l==de||o==de||f==ae||x==ae){const E=<span class="cstat-no" title="statement not covered" >await G(r,i.offset-Ve,Ve),</span>T=<span class="cstat-no" title="statement not covered" >q(E);<span class="cstat-no" title="statement not covered" ></span>if(B(T,0)!=bs)<span class="cstat-no" title="statement not covered" >throw new Error(wr);<span class="cstat-no" title="statement not covered" >l</span></span>=Le(T,8);l</span>et D=<span class="cstat-no" title="statement not covered" >await G(r,l,Ze,-1),</span>k=<span class="cstat-no" title="statement not covered" >q(D);</span>const P=<span class="cstat-no" title="statement not covered" >i.offset-Ve-Ze;<span class="cstat-no" title="statement not covered" ></span>if(B(k,0)!=Jt&amp;&amp;l!=P){const N=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>l=P,c=l-N,D=await G(r,l,Ze,-1),k=q(D)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(B(k,0)!=Jt)<span class="cstat-no" title="statement not covered" >throw new Error(br);<span class="cstat-no" title="statement not covered" >m</span></span>==ae&amp;&amp;(m=B(k,16)),x==ae&amp;&amp;(x=B(k,20)),f==ae&amp;&amp;(f=Le(k,32)),o==de&amp;&amp;(o=Le(k,40)),l-=o}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l&gt;=r.size&amp;&amp;(c=r.size-l-o-pe,l=r.size-o-pe),g!=m)<span class="cstat-no" title="statement not covered" >throw new Error(ut);<span class="cstat-no" title="statement not covered" >i</span></span>f(l&lt;0)<span class="cstat-no" title="statement not covered" >throw new Error(Pe);l</span></span>et h=<span class="cstat-no" title="statement not covered" >0,</span>w=<span class="cstat-no" title="statement not covered" >await G(r,l,o,x),</span>y=<span class="cstat-no" title="statement not covered" >q(w);<span class="cstat-no" title="statement not covered" ></span>if(o){const E=<span class="cstat-no" title="statement not covered" >i.offset-o;<span class="cstat-no" title="statement not covered" ></span>if(B(y,h)!=$t&amp;&amp;l!=E){const T=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>l=E,c+=l-T,w=await G(r,l,o,x),y=q(w)}</span>}</span>c</span>onst O=<span class="cstat-no" title="statement not covered" >i.offset-l-(r.lastDiskOffset||0);<span class="cstat-no" title="statement not covered" ></span>if(o!=O&amp;&amp;O&gt;=0&amp;&amp;(o=O,w=await G(r,l,o,x),y=q(w)),l&lt;0||l&gt;=r.size)<span class="cstat-no" title="statement not covered" >throw new Error(Pe);c</span></span>onst b=<span class="cstat-no" title="statement not covered" >K(e,t,"filenameEncoding"),</span>A=<span class="cstat-no" title="statement not covered" >K(e,t,"commentEncoding");<span class="cstat-no" title="statement not covered" ></span>for(let E=<span class="cstat-no" title="statement not covered" >0;</span>E&lt;f;E++){const T=<span class="cstat-no" title="statement not covered" >new Qi(r,s,e.options);<span class="cstat-no" title="statement not covered" ></span>if(B(y,h)!=$t)<span class="cstat-no" title="statement not covered" >throw new Error(gr);<span class="cstat-no" title="statement not covered" >S</span></span>r(T,y,h+6);c</span>onst D=<span class="cstat-no" title="statement not covered" >!!T.bitFlag.languageEncodingFlag,</span>k=<span class="cstat-no" title="statement not covered" >h+46,</span>P=<span class="cstat-no" title="statement not covered" >k+T.filenameLength,</span>N=<span class="cstat-no" title="statement not covered" >P+T.extraFieldLength,</span>C=<span class="cstat-no" title="statement not covered" >j(y,h+4),</span>v=<span class="cstat-no" title="statement not covered" >(C&amp;0)==0,</span>F=<span class="cstat-no" title="statement not covered" >w.subarray(k,P),</span>ge=<span class="cstat-no" title="statement not covered" >j(y,h+32),</span>I=<span class="cstat-no" title="statement not covered" >N+ge,</span>le=<span class="cstat-no" title="statement not covered" >w.subarray(N,I),</span>U=<span class="cstat-no" title="statement not covered" >D,</span>H=<span class="cstat-no" title="statement not covered" >D,</span>Tt=<span class="cstat-no" title="statement not covered" >v&amp;&amp;(be(y,h+38)&amp;tn)==tn,</span>St=<span class="cstat-no" title="statement not covered" >B(y,h+42)+c;<span class="cstat-no" title="statement not covered" ></span>Object.assign(T,{versionMadeBy:C,msDosCompatible:v,compressedSize:0,uncompressedSize:0,commentLength:ge,directory:Tt,offset:St,diskNumberStart:j(y,h+34),internalFileAttribute:j(y,h+36),externalFileAttribute:B(y,h+38),rawFilename:F,filenameUTF8:U,commentUTF8:H,rawExtraField:w.subarray(P,N)});c</span>onst[At,Or]=<span class="cstat-no" title="statement not covered" >await Promise.all([at(F,U?bn:b||gn),at(le,H?bn:A||gn)]);<span class="cstat-no" title="statement not covered" ></span>Object.assign(T,{rawComment:le,filename:At,comment:Or,directory:Tt||At.endsWith(ks)}),u=Math.max(St,u),await Ar(T,T,y,h+6);c</span>onst je=<span class="cstat-no" title="statement not covered" >new wn(T);<span class="cstat-no" title="statement not covered" ></span>je.getData=<span class="fstat-no" title="function not covered" >(O</span>t,kr)=&gt;<span class="cstat-no" title="statement not covered" >T.getData(Ot,je,kr),</span>h=I;c</span>onst{onprogress:Rt}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(Rt)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await Rt(E+1,f,new wn(T))}</span>catch{}<span class="cstat-no" title="statement not covered" >y</span></span>ield je}</span>c</span>onst S=<span class="cstat-no" title="statement not covered" >K(e,t,"extractPrependedData"),</span>R=<span class="cstat-no" title="statement not covered" >K(e,t,"extractAppendedData");<span class="cstat-no" title="statement not covered" ></span>return S&amp;&amp;(e.prependedData=u&gt;0?await G(r,0,u):new Uint8Array),e.comment=d?await G(r,_+pe,d):new Uint8Array,R&amp;&amp;(e.appendedData=p&lt;r.size?await G(r,p,r.size-p):new Uint8Array),!0}<span class="fstat-no" title="function not covered" ></span>as</span>ync getEntries(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for await(const r of this.getEntriesGenerator(t))<span class="cstat-no" title="statement not covered" >e.push(r);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>as</span>ync close(){}}class Qi{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,r){<span class="cstat-no" title="statement not covered" >Object.assign(this,{reader:t,config:e,options:r})}<span class="fstat-no" title="function not covered" ></span>as</span>ync getData(t,e,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >this,</span>{reader:i,offset:a,diskNumberStart:o,extraFieldAES:l,compressionMethod:_,config:d,bitFlag:p,signature:m,rawLastModDate:g,uncompressedSize:x,compressedSize:f}=<span class="cstat-no" title="statement not covered" >s,</span>c=<span class="cstat-no" title="statement not covered" >e.localDirectory={},</span>u=<span class="cstat-no" title="statement not covered" >await G(i,a,30,o),</span>h=<span class="cstat-no" title="statement not covered" >q(u);</span>let w=<span class="cstat-no" title="statement not covered" >K(s,r,"password");<span class="cstat-no" title="statement not covered" ></span>if(w=w&amp;&amp;w.length&amp;&amp;w,l&amp;&amp;l.originalCompressionMethod!=hs)<span class="cstat-no" title="statement not covered" >throw new Error(ft);<span class="cstat-no" title="statement not covered" >i</span></span>f(_!=_s&amp;&amp;_!=ds)<span class="cstat-no" title="statement not covered" >throw new Error(ft);<span class="cstat-no" title="statement not covered" >i</span></span>f(B(h,0)!=ps)<span class="cstat-no" title="statement not covered" >throw new Error(yr);<span class="cstat-no" title="statement not covered" >S</span></span>r(c,h,4),c.rawExtraField=c.extraFieldLength?await G(i,a+30+c.filenameLength,c.extraFieldLength,o):new Uint8Array,await Ar(s,c,h,4,!0),Object.assign(e,{lastAccessDate:c.lastAccessDate,creationDate:c.creationDate});c</span>onst y=<span class="cstat-no" title="statement not covered" >s.encrypted&amp;&amp;c.encrypted,</span>O=<span class="cstat-no" title="statement not covered" >y&amp;&amp;!l;<span class="cstat-no" title="statement not covered" ></span>if(y){<span class="cstat-no" title="statement not covered" >if(!O&amp;&amp;l.strength===$)<span class="cstat-no" title="statement not covered" >throw new Error(Tr);<span class="cstat-no" title="statement not covered" >i</span></span>f(!w)<span class="cstat-no" title="statement not covered" >throw new Error(Er)}</span></span>c</span>onst b=<span class="cstat-no" title="statement not covered" >a+30+c.filenameLength+c.extraFieldLength,</span>A=<span class="cstat-no" title="statement not covered" >f,</span>S=<span class="cstat-no" title="statement not covered" >i.readable;<span class="cstat-no" title="statement not covered" ></span>Object.assign(S,{diskNumberStart:o,offset:b,size:A});c</span>onst R=<span class="cstat-no" title="statement not covered" >K(s,r,"signal"),</span>E=<span class="cstat-no" title="statement not covered" >K(s,r,"checkPasswordOnly");<span class="cstat-no" title="statement not covered" ></span>E&amp;&amp;(t=new WritableStream),t=ir(t),await Re(t,x);c</span>onst{writable:T}=<span class="cstat-no" title="statement not covered" >t,</span>{onstart:D,onprogress:k,onend:P}=<span class="cstat-no" title="statement not covered" >r,</span>N=<span class="cstat-no" title="statement not covered" >{options:{codecType:Zn,password:w,zipCrypto:O,encryptionStrength:l&amp;&amp;l.strength,signed:K(s,r,"checkSignature"),passwordVerification:O&amp;&amp;(p.dataDescriptor?g&gt;&gt;&gt;8&amp;255:m&gt;&gt;&gt;24&amp;255),signature:m,compressed:_!=0,encrypted:y,useWebWorkers:K(s,r,"useWebWorkers"),useCompressionStream:K(s,r,"useCompressionStream"),transferStreams:K(s,r,"transferStreams"),checkPasswordOnly:E},config:d,streamOptions:{signal:R,size:A,onstart:D,onprogress:k,onend:P}};</span>let C=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >({outputSize:C}=await bi({readable:S,writable:T},N))}</span>catch(v){<span class="cstat-no" title="statement not covered" >if(!E||v.message!=ht)<span class="cstat-no" title="statement not covered" >throw v}</span></span>finally{const v=<span class="cstat-no" title="statement not covered" >K(s,r,"preventClose");<span class="cstat-no" title="statement not covered" ></span>T.size+=C,!v&amp;&amp;!T.locked&amp;&amp;await T.getWriter().close()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn E?void 0:t.getData?t.getData():T}</span>}function <span class="fstat-no" title="function not covered" >Sr(</span>n,t,e){const r=<span class="cstat-no" title="statement not covered" >n.rawBitFlag=j(t,e+2),</span>s=<span class="cstat-no" title="statement not covered" >(r&amp;Qt)==Qt,</span>i=<span class="cstat-no" title="statement not covered" >B(t,e+6);<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,{encrypted:s,version:j(t,e),bitFlag:{level:(r&amp;Os)&gt;&gt;1,dataDescriptor:(r&amp;zt)==zt,languageEncodingFlag:(r&amp;en)==en},rawLastModDate:i,lastModDate:sa(i),filenameLength:j(t,e+22),extraFieldLength:j(t,e+24)})}</span>async function <span class="fstat-no" title="function not covered" >Ar(</span>n,t,e,r,s){const{rawExtraField:i}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >t.extraField=new Map,</span>o=<span class="cstat-no" title="statement not covered" >q(new Uint8Array(i));</span>let l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >for(;l&lt;i.length;){const u=<span class="cstat-no" title="statement not covered" >j(o,l),</span>h=<span class="cstat-no" title="statement not covered" >j(o,l+2);<span class="cstat-no" title="statement not covered" ></span>a.set(u,{type:u,data:i.slice(l+4,l+4+h)}),l+=4+h}</span>}</span>catch{}c</span>onst _=<span class="cstat-no" title="statement not covered" >j(e,r+4);<span class="cstat-no" title="statement not covered" ></span>Object.assign(t,{signature:B(e,r+10),uncompressedSize:B(e,r+18),compressedSize:B(e,r+14)});c</span>onst d=<span class="cstat-no" title="statement not covered" >a.get(gs);<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;(zi(d,t),t.extraFieldZip64=d);c</span>onst p=<span class="cstat-no" title="statement not covered" >a.get(Ss);<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(await yn(p,or,cr,t,n),t.extraFieldUnicodePath=p);c</span>onst m=<span class="cstat-no" title="statement not covered" >a.get(As);<span class="cstat-no" title="statement not covered" ></span>m&amp;&amp;(await yn(m,lr,fr,t,n),t.extraFieldUnicodeComment=m);c</span>onst g=<span class="cstat-no" title="statement not covered" >a.get(ys);<span class="cstat-no" title="statement not covered" ></span>g?(ea(g,t,_),t.extraFieldAES=g):t.compressionMethod=_;c</span>onst x=<span class="cstat-no" title="statement not covered" >a.get(xs);<span class="cstat-no" title="statement not covered" ></span>x&amp;&amp;(ta(x,t),t.extraFieldNTFS=x);c</span>onst f=<span class="cstat-no" title="statement not covered" >a.get(Ts);<span class="cstat-no" title="statement not covered" ></span>f&amp;&amp;(na(f,t,s),t.extraFieldExtendedTimestamp=f);c</span>onst c=<span class="cstat-no" title="statement not covered" >a.get(Rs);<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;(t.extraFieldUSDZ=c)}</span>function <span class="fstat-no" title="function not covered" >zi(</span>n,t){<span class="cstat-no" title="statement not covered" >t.zip64=!0;c</span>onst e=<span class="cstat-no" title="statement not covered" >q(n.data),</span>r=<span class="cstat-no" title="statement not covered" >Xi.filter(<span class="fstat-no" title="function not covered" >([</span>s,i])=&gt;<span class="cstat-no" title="statement not covered" >t[s]==i)</span>;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;r.length;s++){const[a,o]=<span class="cstat-no" title="statement not covered" >r[s];<span class="cstat-no" title="statement not covered" ></span>if(t[a]==o){const l=<span class="cstat-no" title="statement not covered" >$i[o];<span class="cstat-no" title="statement not covered" ></span>t[a]=n[a]=l.getValue(e,i),i+=l.bytes}</span>else <span class="cstat-no" title="statement not covered" >if(n[a])<span class="cstat-no" title="statement not covered" >throw new Error(xr)}</span></span></span>}</span>async function <span class="fstat-no" title="function not covered" >yn(</span>n,t,e,r,s){const i=<span class="cstat-no" title="statement not covered" >q(n.data),</span>a=<span class="cstat-no" title="statement not covered" >new Ue;<span class="cstat-no" title="statement not covered" ></span>a.append(s[e]);c</span>onst o=<span class="cstat-no" title="statement not covered" >q(new Uint8Array(4));<span class="cstat-no" title="statement not covered" ></span>o.setUint32(0,a.get(),!0);c</span>onst l=<span class="cstat-no" title="statement not covered" >B(i,1);<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,{version:be(i,0),[t]:at(n.data.subarray(5)),valid:!s.bitFlag.languageEncodingFlag&amp;&amp;l==B(o,0)}),n.valid&amp;&amp;(r[t]=n[t],r[t+"UTF8"]=!0)}</span>function <span class="fstat-no" title="function not covered" >ea(</span>n,t,e){const r=<span class="cstat-no" title="statement not covered" >q(n.data),</span>s=<span class="cstat-no" title="statement not covered" >be(r,4);<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,{vendorVersion:be(r,0),vendorId:be(r,2),strength:s,originalCompressionMethod:e,compressionMethod:j(r,5)}),t.compressionMethod=n.compressionMethod}</span>function <span class="fstat-no" title="function not covered" >ta(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >q(n.data);</span>let r=<span class="cstat-no" title="statement not covered" >4,</span>s;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >for(;r&lt;n.data.length&amp;&amp;!s;){const i=<span class="cstat-no" title="statement not covered" >j(e,r),</span>a=<span class="cstat-no" title="statement not covered" >j(e,r+2);<span class="cstat-no" title="statement not covered" ></span>i==Es&amp;&amp;(s=n.data.slice(r+4,r+4+a)),r+=4+a}</span>}</span>catch{}<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >if(s&amp;&amp;s.length==24){const i=<span class="cstat-no" title="statement not covered" >q(s),</span>a=<span class="cstat-no" title="statement not covered" >i.getBigUint64(0,!0),</span>o=<span class="cstat-no" title="statement not covered" >i.getBigUint64(8,!0),</span>l=<span class="cstat-no" title="statement not covered" >i.getBigUint64(16,!0);<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,{rawLastModDate:a,rawLastAccessDate:o,rawCreationDate:l});c</span>onst _=<span class="cstat-no" title="statement not covered" >Je(a),</span>d=<span class="cstat-no" title="statement not covered" >Je(o),</span>p=<span class="cstat-no" title="statement not covered" >Je(l),</span>m=<span class="cstat-no" title="statement not covered" >{lastModDate:_,lastAccessDate:d,creationDate:p};<span class="cstat-no" title="statement not covered" ></span>Object.assign(n,m),Object.assign(t,m)}</span>}</span>catch{}}</span>function <span class="fstat-no" title="function not covered" >na(</span>n,t,e){const r=<span class="cstat-no" title="statement not covered" >q(n.data),</span>s=<span class="cstat-no" title="statement not covered" >be(r,0),</span>i=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e?((s&amp;1)==1&amp;&amp;(i.push(ct),a.push(lt)),(s&amp;2)==2&amp;&amp;(i.push(hr),a.push(ji)),(s&amp;4)==4&amp;&amp;(i.push(pr),a.push(qi))):n.data.length&gt;=5&amp;&amp;(i.push(ct),a.push(lt));l</span>et o=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>i.forEach(<span class="fstat-no" title="function not covered" >(l</span>,_)=&gt;{<span class="cstat-no" title="statement not covered" >if(n.data.length&gt;=o+4){const d=<span class="cstat-no" title="statement not covered" >B(r,o);<span class="cstat-no" title="statement not covered" ></span>t[l]=n[l]=new Date(d*1e3);c</span>onst p=<span class="cstat-no" title="statement not covered" >a[_];<span class="cstat-no" title="statement not covered" ></span>n[p]=d}<span class="cstat-no" title="statement not covered" ></span>o</span>+=4}</span>)}</span>async function <span class="fstat-no" title="function not covered" >ra(</span>n,t,e,r,s){const i=<span class="cstat-no" title="statement not covered" >new Uint8Array(4),</span>a=<span class="cstat-no" title="statement not covered" >q(i);<span class="cstat-no" title="statement not covered" ></span>ia(a,0,t);c</span>onst o=<span class="cstat-no" title="statement not covered" >r+s;<span class="cstat-no" title="statement not covered" ></span>return await l(r)||await l(Math.min(o,e));a</span>sync function <span class="fstat-no" title="function not covered" >l(</span>_){const d=<span class="cstat-no" title="statement not covered" >e-_,</span>p=<span class="cstat-no" title="statement not covered" >await G(n,d,_);<span class="cstat-no" title="statement not covered" ></span>for(let m=<span class="cstat-no" title="statement not covered" >p.length-r;</span>m&gt;=0;m--)<span class="cstat-no" title="statement not covered" >if(p[m]==i[0]&amp;&amp;p[m+1]==i[1]&amp;&amp;p[m+2]==i[2]&amp;&amp;p[m+3]==i[3])<span class="cstat-no" title="statement not covered" >return{offset:d+m,buffer:p.slice(m,m+r).buffer}}</span></span></span>}function <span class="fstat-no" title="function not covered" >K(</span>n,t,e){<span class="cstat-no" title="statement not covered" >return t[e]===$?n.options[e]:t[e]}</span>function <span class="fstat-no" title="function not covered" >sa(</span>n){const t=<span class="cstat-no" title="statement not covered" >(n&amp;4294901760)&gt;&gt;16,</span>e=<span class="cstat-no" title="statement not covered" >n&amp;65535;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return new Date(1980+((t&amp;65024)&gt;&gt;9),((t&amp;480)&gt;&gt;5)-1,t&amp;31,(e&amp;63488)&gt;&gt;11,(e&amp;2016)&gt;&gt;5,(e&amp;31)*2,0)}</span>catch{}}</span>function <span class="fstat-no" title="function not covered" >Je(</span>n){<span class="cstat-no" title="statement not covered" >return new Date(Number(n/BigInt(1e4)-BigInt(116444736e5)))}</span>function <span class="fstat-no" title="function not covered" >be(</span>n,t){<span class="cstat-no" title="statement not covered" >return n.getUint8(t)}</span>function <span class="fstat-no" title="function not covered" >j(</span>n,t){<span class="cstat-no" title="statement not covered" >return n.getUint16(t,!0)}</span>function <span class="fstat-no" title="function not covered" >B(</span>n,t){<span class="cstat-no" title="statement not covered" >return n.getUint32(t,!0)}</span>function <span class="fstat-no" title="function not covered" >Le(</span>n,t){<span class="cstat-no" title="statement not covered" >return Number(n.getBigUint64(t,!0))}</span>function <span class="fstat-no" title="function not covered" >ia(</span>n,t,e){<span class="cstat-no" title="statement not covered" >n.setUint32(t,e,!0)}</span>function <span class="fstat-no" title="function not covered" >q(</span>n){<span class="cstat-no" title="statement not covered" >return new DataView(n.buffer)}<span class="cstat-no" title="statement not covered" ></span>kn({Inflate:us});c</span>onst aa=<span class="cstat-no" title="statement not covered" >Object.freeze(Object.defineProperty({__proto__:null,BlobReader:yt,BlobWriter:Jn,Data64URIReader:ki,Data64URIWriter:Ci,ERR_BAD_FORMAT:Pe,ERR_CENTRAL_DIRECTORY_NOT_FOUND:gr,ERR_ENCRYPTED:Er,ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND:br,ERR_EOCDR_NOT_FOUND:mr,ERR_EOCDR_ZIP64_NOT_FOUND:wr,ERR_EXTRAFIELD_ZIP64_NOT_FOUND:xr,ERR_HTTP_RANGE:ke,ERR_INVALID_PASSWORD:dt,ERR_INVALID_SIGNATURE:_t,ERR_ITERATOR_COMPLETED_TOO_SOON:Xn,ERR_LOCAL_FILE_HEADER_NOT_FOUND:yr,ERR_SPLIT_ZIP_FILE:ut,ERR_UNSUPPORTED_COMPRESSION:ft,ERR_UNSUPPORTED_ENCRYPTION:Tr,HttpRangeReader:Li,HttpReader:rr,Reader:ce,SplitDataReader:Et,SplitDataWriter:ve,SplitZipReader:vi,SplitZipWriter:Hi,TextReader:Di,TextWriter:Ii,Uint8ArrayReader:Fi,Uint8ArrayWriter:Ui,Writer:gt,ZipReader:Ji,configure:kn,getMimeType:Ns,initReader:sr,initStream:Re,initWriter:ir,readUint8Array:G,terminateWorkers:gi},Symbol.toStringTag,{value:"Module"})),</span>Ee=<span class="cstat-no" title="statement not covered" >aa;</span>class oa{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >M(this,"_zipReader");<span class="cstat-no" title="statement not covered" >M</span>(this,"_entriesPromise");<span class="cstat-no" title="statement not covered" >M</span>(this,"_traceURL");<span class="cstat-no" title="statement not covered" >t</span>his._traceURL=t,Ee.configure({baseURL:self.location.href}),this._zipReader=new Ee.ZipReader(new Ee.HttpReader(la(t),{mode:"cors",preventHeadRequest:!0}),{useWebWorkers:!1}),this._entriesPromise=this._zipReader.getEntries({onprogress:e}).then(<span class="fstat-no" title="function not covered" >r=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>for(const i of r)<span class="cstat-no" title="statement not covered" >s.set(i.filename,i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>)}<span class="fstat-no" title="function not covered" ></span>is</span>Live(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>tr</span>aceURL(){<span class="cstat-no" title="statement not covered" >return this._traceURL}<span class="fstat-no" title="function not covered" ></span>as</span>ync entryNames(){<span class="cstat-no" title="statement not covered" >return[...(await this._entriesPromise).keys()]}<span class="fstat-no" title="function not covered" ></span>as</span>ync hasEntry(t){<span class="cstat-no" title="statement not covered" >return(await this._entriesPromise).has(t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync readText(t){var i;const r=<span class="cstat-no" title="statement not covered" >(await this._entriesPromise).get(t);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new Ee.TextWriter;<span class="cstat-no" title="statement not covered" ></span>return await((i=r.getData)==null?void 0:i.call(r,s)),s.getData()}<span class="fstat-no" title="function not covered" ></span>as</span>ync readBlob(t){const r=<span class="cstat-no" title="statement not covered" >(await this._entriesPromise).get(t);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new Ee.BlobWriter;<span class="cstat-no" title="statement not covered" ></span>return await r.getData(s),s.getData()}</span>}class ca{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >M(this,"_entriesPromise");<span class="cstat-no" title="statement not covered" >M</span>(this,"_traceURL");<span class="cstat-no" title="statement not covered" >t</span>his._traceURL=t,this._entriesPromise=fetch("/trace/file?path="+encodeURIComponent(t)).then(<span class="fstat-no" title="function not covered" >as</span>ync e=&gt;{const r=<span class="cstat-no" title="statement not covered" >JSON.parse(await e.text()),</span>s=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>for(const i of r.entries)<span class="cstat-no" title="statement not covered" >s.set(i.name,i.path);<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>)}<span class="fstat-no" title="function not covered" ></span>is</span>Live(){<span class="cstat-no" title="statement not covered" >return!0}<span class="fstat-no" title="function not covered" ></span>tr</span>aceURL(){<span class="cstat-no" title="statement not covered" >return this._traceURL}<span class="fstat-no" title="function not covered" ></span>as</span>ync entryNames(){<span class="cstat-no" title="statement not covered" >return[...(await this._entriesPromise).keys()]}<span class="fstat-no" title="function not covered" ></span>as</span>ync hasEntry(t){<span class="cstat-no" title="statement not covered" >return(await this._entriesPromise).has(t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync readText(t){const e=<span class="cstat-no" title="statement not covered" >await this._readEntry(t);<span class="cstat-no" title="statement not covered" ></span>return e==null?void 0:e.text()}<span class="fstat-no" title="function not covered" ></span>as</span>ync readBlob(t){const e=<span class="cstat-no" title="statement not covered" >await this._readEntry(t);<span class="cstat-no" title="statement not covered" ></span>return(e==null?void 0:e.status)===200?await(e==null?void 0:e.blob()):void 0}<span class="fstat-no" title="function not covered" ></span>as</span>ync _readEntry(t){const r=<span class="cstat-no" title="statement not covered" >(await this._entriesPromise).get(t);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return fetch("/trace/file?path="+encodeURIComponent(r))}</span></span>}function <span class="fstat-no" title="function not covered" >la(</span>n){let t=<span class="cstat-no" title="statement not covered" >n.startsWith("http")||n.startsWith("blob")?n:`file?path=${encodeURIComponent(n)}`;<span class="cstat-no" title="statement not covered" ></span>return t.startsWith("https://www.dropbox.com/")&amp;&amp;(t="https://dl.dropboxusercontent.com/"+t.substring(24)),t}<span class="cstat-no" title="statement not covered" ></span>self.addEventListener("install",<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >self.skipWaiting()}</span>);<span class="cstat-no" title="statement not covered" >s</span>elf.addEventListener("activate",<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >n.waitUntil(self.clients.claim())}</span>);c</span>onst fa=<span class="cstat-no" title="statement not covered" >new URL(self.registration.scope).pathname,</span>ue=<span class="cstat-no" title="statement not covered" >new Map,</span>He=<span class="cstat-no" title="statement not covered" >new Map;</span>async function <span class="fstat-no" title="function not covered" >ua(</span>n,t,e,r){var o;<span class="cstat-no" title="statement not covered" >await Rr();l</span>et s=<span class="cstat-no" title="statement not covered" >He.get(e);<span class="cstat-no" title="statement not covered" ></span>s||(s=new Set,He.set(e,s)),s.add(n);c</span>onst i=<span class="cstat-no" title="statement not covered" >new Yr;<span class="cstat-no" title="statement not covered" ></span>try{const[l,_]=<span class="cstat-no" title="statement not covered" >Ir(r,[.5,.4,.1]),</span>d=<span class="cstat-no" title="statement not covered" >n.endsWith("json")?new ca(n):new oa(n,l);<span class="cstat-no" title="statement not covered" ></span>await i.load(d,_)}</span>catch(l){<span class="cstat-no" title="statement not covered" >throw console.error(l),(o=l==null?void 0:l.message)!=null&amp;&amp;o.includes("Cannot find .trace file")&amp;&amp;await i.hasEntry("index.html")?new Error("Could not load trace. Did you upload a Playwright HTML report instead? Make sure to extract the archive first and then double-click the index.html file or put it on a web server."):t?new Error(`Could not load trace from ${t}. Make sure to upload a valid Playwright trace.`):new Error(`Could not load trace from ${n}. Make sure a valid Playwright Trace is accessible over this url.`)}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >new Wr(i.storage(),<span class="fstat-no" title="function not covered" >l=</span>&gt;<span class="cstat-no" title="statement not covered" >i.resourceForSha1(l))</span>;<span class="cstat-no" title="statement not covered" ></span>return ue.set(n,{traceModel:i,snapshotServer:a}),i}</span>async function <span class="fstat-no" title="function not covered" >da(</span>n){<span class="cstat-no" title="statement not covered" >if(n.request.url.startsWith("chrome-extension://"))<span class="cstat-no" title="statement not covered" >return fetch(n.request);c</span></span>onst t=<span class="cstat-no" title="statement not covered" >n.request,</span>e=<span class="cstat-no" title="statement not covered" >await self.clients.get(n.clientId),</span>r=<span class="cstat-no" title="statement not covered" >self.registration.scope.startsWith("https://");<span class="cstat-no" title="statement not covered" ></span>if(t.url.startsWith(self.registration.scope)){const l=<span class="cstat-no" title="statement not covered" >new URL(ze(t.url)),</span>_=<span class="cstat-no" title="statement not covered" >l.pathname.substring(fa.length-1);<span class="cstat-no" title="statement not covered" ></span>if(_==="/ping")<span class="cstat-no" title="statement not covered" >return await Rr(),new Response(null,{status:200});c</span></span>onst d=<span class="cstat-no" title="statement not covered" >l.searchParams.get("trace");<span class="cstat-no" title="statement not covered" ></span>if(_==="/contexts")<span class="cstat-no" title="statement not covered" >try{const p=<span class="cstat-no" title="statement not covered" >await ua(d,l.searchParams.get("traceFileName"),n.clientId,<span class="fstat-no" title="function not covered" >(m</span>,g)=&gt;{<span class="cstat-no" title="statement not covered" >e.postMessage({method:"progress",params:{done:m,total:g}})}</span>);<span class="cstat-no" title="statement not covered" ></span>return new Response(JSON.stringify(p.contextEntries),{status:200,headers:{"Content-Type":"application/json"}})}</span>catch(p){<span class="cstat-no" title="statement not covered" >return new Response(JSON.stringify({error:p==null?void 0:p.message}),{status:500,headers:{"Content-Type":"application/json"}})}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(_.startsWith("/snapshotInfo/")){const{snapshotServer:p}=<span class="cstat-no" title="statement not covered" >ue.get(d)||{};<span class="cstat-no" title="statement not covered" ></span>return p?p.serveSnapshotInfo(_,l.searchParams):new Response(null,{status:404})}<span class="cstat-no" title="statement not covered" ></span>i</span>f(_.startsWith("/snapshot/")){const{snapshotServer:p}=<span class="cstat-no" title="statement not covered" >ue.get(d)||{};<span class="cstat-no" title="statement not covered" ></span>if(!p)<span class="cstat-no" title="statement not covered" >return new Response(null,{status:404});c</span></span>onst m=<span class="cstat-no" title="statement not covered" >p.serveSnapshot(_,l.searchParams,l.href);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;m.headers.set("Content-Security-Policy","upgrade-insecure-requests"),m}<span class="cstat-no" title="statement not covered" ></span>i</span>f(_.startsWith("/sha1/")){const p=<span class="cstat-no" title="statement not covered" >l.searchParams.has("download"),</span>m=<span class="cstat-no" title="statement not covered" >_.slice(6);<span class="cstat-no" title="statement not covered" ></span>for(const g of ue.values()){const x=<span class="cstat-no" title="statement not covered" >await g.traceModel.resourceForSha1(m);<span class="cstat-no" title="statement not covered" ></span>if(x)<span class="cstat-no" title="statement not covered" >return new Response(x,{status:200,headers:p?_a(g.traceModel,m):void 0})}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn new Response(null,{status:404})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn fetch(n.request)}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >ze(e.url),</span>i=<span class="cstat-no" title="statement not covered" >new URL(s).searchParams.get("trace"),</span>{snapshotServer:a}=<span class="cstat-no" title="statement not covered" >ue.get(i)||{};<span class="cstat-no" title="statement not covered" ></span>if(!a)<span class="cstat-no" title="statement not covered" >return new Response(null,{status:404});c</span></span>onst o=<span class="cstat-no" title="statement not covered" >[t.url];<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;t.url.startsWith("https://")&amp;&amp;o.push(t.url.replace(/^https/,"http")),a.serveResource(o,t.method,s)}</span>function <span class="fstat-no" title="function not covered" >_a(</span>n,t){const e=<span class="cstat-no" title="statement not covered" >n.attachmentForSha1(t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >new Headers;<span class="cstat-no" title="statement not covered" ></span>return r.set("Content-Disposition",`attachment; filename="attachment"; filename*=UTF-8''${encodeURIComponent(e.name)}`),e.contentType&amp;&amp;r.set("Content-Type",e.contentType),r}</span>async function <span class="fstat-no" title="function not covered" >Rr(</span>){const n=<span class="cstat-no" title="statement not covered" >await self.clients.matchAll(),</span>t=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const[e,r]of He)<span class="cstat-no" title="statement not covered" >n.find(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.id===e)</span>?r.forEach(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t.add(s))</span>:He.delete(e);<span class="cstat-no" title="statement not covered" >f</span></span>or(const e of ue.keys())<span class="cstat-no" title="statement not covered" >t.has(e)||ue.delete(e)}<span class="cstat-no" title="statement not covered" ></span></span>self.addEventListener("fetch",<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >n.respondWith(da(n))}</span>);</span>
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2024-10-24T15:06:32.590Z
            </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    