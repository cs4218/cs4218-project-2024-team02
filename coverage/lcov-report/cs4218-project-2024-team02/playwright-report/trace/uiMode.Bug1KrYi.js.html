
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for cs4218-project-2024-team02/playwright-report/trace/uiMode.Bug1KrYi.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">cs4218-project-2024-team02/playwright-report/trace</a> uiMode.Bug1KrYi.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/608</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/604</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/246</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/7</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">function <span class="fstat-no" title="function not covered" >__vite__mapDeps(</span>indexes) {
<span class="cstat-no" title="statement not covered" >  if (!__vite__mapDeps.viteFileDeps) {</span>
<span class="cstat-no" title="statement not covered" >    __vite__mapDeps.viteFileDeps = ["./assets/xtermModule-BeNbaIVa.js","./xtermModule.DSXBckUd.css"]</span>
  }
<span class="cstat-no" title="statement not covered" >  return indexes.map(<span class="fstat-no" title="function not covered" >(i</span>) =&gt; <span class="cstat-no" title="statement not covered" >__vite__mapDeps.viteFileDeps[i])</span></span>
}
var bt=<span class="cstat-no" title="statement not covered" >Object.defineProperty;</span>var St=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(r</span>,t,e)=&gt;<span class="cstat-no" title="statement not covered" >t in r?bt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;</span></span>var F=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(r</span>,t,e)=&gt;(<span class="cstat-no" title="statement not covered" >St(r,typeof t!="symbol"?t+"":t,e),e)</span>;</span>import{u as Tt,r as V,d as kt,_ as jt,e as yt,f as Et,j as o,R as h,s as ut,m as It,g as X,a as N,h as Rt,i as Bt,k as nt,W as Ct,M as Nt,l as Pt,T as Lt,S as Dt,t as Mt,b as Ft,c as Ot}from"./assets/testServerConnection-Dj8RHZjQ.js";var At=<span class="cstat-no" title="statement not covered" >{};</span>class et{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.isListing=!1,this._tests=new Map,this._rootSuite=new q("","root"),this._options=e,this._reporter=t}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._rootSuite._entries=[],this._tests.clear()}<span class="fstat-no" title="function not covered" ></span>di</span>spatch(t){const{method:e,params:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(e==="onConfigure"){<span class="cstat-no" title="statement not covered" >this._onConfigure(s.config);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onProject"){<span class="cstat-no" title="statement not covered" >this._onProject(s.project);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onBegin"){<span class="cstat-no" title="statement not covered" >this._onBegin();<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onTestBegin"){<span class="cstat-no" title="statement not covered" >this._onTestBegin(s.testId,s.result);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onTestEnd"){<span class="cstat-no" title="statement not covered" >this._onTestEnd(s.test,s.result);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onStepBegin"){<span class="cstat-no" title="statement not covered" >this._onStepBegin(s.testId,s.resultId,s.step);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onStepEnd"){<span class="cstat-no" title="statement not covered" >this._onStepEnd(s.testId,s.resultId,s.step);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onError"){<span class="cstat-no" title="statement not covered" >this._onError(s.error);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onStdIO"){<span class="cstat-no" title="statement not covered" >this._onStdIO(s.type,s.testId,s.resultId,s.data,s.isBase64);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e==="onEnd")<span class="cstat-no" title="statement not covered" >return this._onEnd(s.result);<span class="cstat-no" title="statement not covered" >i</span></span>f(e==="onExit")<span class="cstat-no" title="statement not covered" >return this._onExit()}<span class="fstat-no" title="function not covered" ></span></span>_o</span>nConfigure(t){var e,s;<span class="cstat-no" title="statement not covered" >this._rootDir=t.rootDir,this._config=this._parseConfig(t),(s=(e=this._reporter).onConfigure)==null||s.call(e,this._config)}<span class="fstat-no" title="function not covered" ></span>_o</span>nProject(t){let e=<span class="cstat-no" title="statement not covered" >this._options.mergeProjects?this._rootSuite.suites.find(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.project().name===t.name)</span>:void 0;<span class="cstat-no" title="statement not covered" ></span>e||(e=new q(t.name,"project"),this._rootSuite._addSuite(e)),e._project=this._parseProject(t);<span class="cstat-no" title="statement not covered" >f</span>or(const s of t.suites)<span class="cstat-no" title="statement not covered" >this._mergeSuiteInto(s,e)}<span class="fstat-no" title="function not covered" ></span></span>_o</span>nBegin(){var t,e;<span class="cstat-no" title="statement not covered" >(e=(t=this._reporter).onBegin)==null||e.call(t,this._rootSuite)}<span class="fstat-no" title="function not covered" ></span>_o</span>nTestBegin(t,e){var d,a;const s=<span class="cstat-no" title="statement not covered" >this._tests.get(t);<span class="cstat-no" title="statement not covered" ></span>this._options.clearPreviousResultsWhenTestBegins&amp;&amp;(s.results=[]);c</span>onst i=<span class="cstat-no" title="statement not covered" >s._createTestResult(e.id);<span class="cstat-no" title="statement not covered" ></span>i.retry=e.retry,i.workerIndex=e.workerIndex,i.parallelIndex=e.parallelIndex,i.setStartTimeNumber(e.startTime),(a=(d=this._reporter).onTestBegin)==null||a.call(d,s,i)}<span class="fstat-no" title="function not covered" ></span>_o</span>nTestEnd(t,e){var d,a,f;const s=<span class="cstat-no" title="statement not covered" >this._tests.get(t.testId);<span class="cstat-no" title="statement not covered" ></span>s.timeout=t.timeout,s.expectedStatus=t.expectedStatus,s.annotations=t.annotations;c</span>onst i=<span class="cstat-no" title="statement not covered" >s.results.find(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n._id===e.id)</span>;<span class="cstat-no" title="statement not covered" ></span>i.duration=e.duration,i.status=e.status,i.errors=e.errors,i.error=(d=i.errors)==null?void 0:d[0],i.attachments=this._parseAttachments(e.attachments),(f=(a=this._reporter).onTestEnd)==null||f.call(a,s,i),i._stepMap=new Map}<span class="fstat-no" title="function not covered" ></span>_o</span>nStepBegin(t,e,s){var m,u;const i=<span class="cstat-no" title="statement not covered" >this._tests.get(t),</span>d=<span class="cstat-no" title="statement not covered" >i.results.find(<span class="fstat-no" title="function not covered" >g=</span>&gt;<span class="cstat-no" title="statement not covered" >g._id===e)</span>,</span>a=<span class="cstat-no" title="statement not covered" >s.parentStepId?d._stepMap.get(s.parentStepId):void 0,</span>f=<span class="cstat-no" title="statement not covered" >this._absoluteLocation(s.location),</span>n=<span class="cstat-no" title="statement not covered" >new Ut(s,a,f);<span class="cstat-no" title="statement not covered" ></span>a?a.steps.push(n):d.steps.push(n),d._stepMap.set(s.id,n),(u=(m=this._reporter).onStepBegin)==null||u.call(m,i,d,n)}<span class="fstat-no" title="function not covered" ></span>_o</span>nStepEnd(t,e,s){var f,n;const i=<span class="cstat-no" title="statement not covered" >this._tests.get(t),</span>d=<span class="cstat-no" title="statement not covered" >i.results.find(<span class="fstat-no" title="function not covered" >m=</span>&gt;<span class="cstat-no" title="statement not covered" >m._id===e)</span>,</span>a=<span class="cstat-no" title="statement not covered" >d._stepMap.get(s.id);<span class="cstat-no" title="statement not covered" ></span>a.duration=s.duration,a.error=s.error,(n=(f=this._reporter).onStepEnd)==null||n.call(f,i,d,a)}<span class="fstat-no" title="function not covered" ></span>_o</span>nError(t){var e,s;<span class="cstat-no" title="statement not covered" >(s=(e=this._reporter).onError)==null||s.call(e,t)}<span class="fstat-no" title="function not covered" ></span>_o</span>nStdIO(t,e,s,i,d){var m,u,g,k;const a=<span class="cstat-no" title="statement not covered" >d?globalThis.Buffer?Buffer.from(i,"base64"):atob(i):i,</span>f=<span class="cstat-no" title="statement not covered" >e?this._tests.get(e):void 0,</span>n=<span class="cstat-no" title="statement not covered" >f&amp;&amp;s?f.results.find(<span class="fstat-no" title="function not covered" >l=</span>&gt;<span class="cstat-no" title="statement not covered" >l._id===s)</span>:void 0;<span class="cstat-no" title="statement not covered" ></span>t==="stdout"?(n==null||n.stdout.push(a),(u=(m=this._reporter).onStdOut)==null||u.call(m,a,f,n)):(n==null||n.stderr.push(a),(k=(g=this._reporter).onStdErr)==null||k.call(g,a,f,n))}<span class="fstat-no" title="function not covered" ></span>as</span>ync _onEnd(t){var e,s;<span class="cstat-no" title="statement not covered" >await((s=(e=this._reporter).onEnd)==null?void 0:s.call(e,{status:t.status,startTime:new Date(t.startTime),duration:t.duration}))}<span class="fstat-no" title="function not covered" ></span>_o</span>nExit(){var t,e;<span class="cstat-no" title="statement not covered" >return(e=(t=this._reporter).onExit)==null?void 0:e.call(t)}<span class="fstat-no" title="function not covered" ></span>_p</span>arseConfig(t){const e=<span class="cstat-no" title="statement not covered" >{...Kt,...t};<span class="cstat-no" title="statement not covered" ></span>return this._options.configOverrides&amp;&amp;(e.configFile=this._options.configOverrides.configFile,e.reportSlowTests=this._options.configOverrides.reportSlowTests,e.quiet=this._options.configOverrides.quiet,e.reporter=[...this._options.configOverrides.reporter]),e}<span class="fstat-no" title="function not covered" ></span>_p</span>arseProject(t){<span class="cstat-no" title="statement not covered" >return{metadata:t.metadata,name:t.name,outputDir:this._absolutePath(t.outputDir),repeatEach:t.repeatEach,retries:t.retries,testDir:this._absolutePath(t.testDir),testIgnore:Q(t.testIgnore),testMatch:Q(t.testMatch),timeout:t.timeout,grep:Q(t.grep),grepInvert:Q(t.grepInvert),dependencies:t.dependencies,teardown:t.teardown,snapshotDir:this._absolutePath(t.snapshotDir),use:{}}}<span class="fstat-no" title="function not covered" ></span>_p</span>arseAttachments(t){<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;(<span class="cstat-no" title="statement not covered" >{...e,body:e.base64&amp;&amp;globalThis.Buffer?Buffer.from(e.base64,"base64"):void 0})</span>)}<span class="fstat-no" title="function not covered" ></span>_m</span>ergeSuiteInto(t,e){let s=<span class="cstat-no" title="statement not covered" >e.suites.find(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i.title===t.title)</span>;<span class="cstat-no" title="statement not covered" ></span>s||(s=new q(t.title,e.type==="project"?"file":"describe"),e._addSuite(s)),s.location=this._absoluteLocation(t.location),t.entries.forEach(<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >"testId"in i?this._mergeTestInto(i,s):this._mergeSuiteInto(i,s)}</span>)}<span class="fstat-no" title="function not covered" ></span>_m</span>ergeTestInto(t,e){let s=<span class="cstat-no" title="statement not covered" >this._options.mergeTestCases?e.tests.find(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i.title===t.title&amp;&amp;i.repeatEachIndex===t.repeatEachIndex)</span>:void 0;<span class="cstat-no" title="statement not covered" ></span>s||(s=new Wt(t.testId,t.title,this._absoluteLocation(t.location),t.repeatEachIndex),e._addTest(s),this._tests.set(s.id,s)),this._updateTest(t,s)}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateTest(t,e){<span class="cstat-no" title="statement not covered" >return e.id=t.testId,e.location=this._absoluteLocation(t.location),e.retries=t.retries,e.tags=t.tags??[],e.annotations=t.annotations??[],e}<span class="fstat-no" title="function not covered" ></span>_a</span>bsoluteLocation(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;{...t,file:this._absolutePath(t.file)}}<span class="fstat-no" title="function not covered" ></span>_a</span>bsolutePath(t){<span class="cstat-no" title="statement not covered" >if(t!==void 0)<span class="cstat-no" title="statement not covered" >return this._options.resolvePath?this._options.resolvePath(this._rootDir,t):this._rootDir+"/"+t}</span></span>}class q{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._entries=[],this._requireFile="",this._parallelMode="none",this.title=t,this._type=e}<span class="fstat-no" title="function not covered" ></span>ge</span>t type(){<span class="cstat-no" title="statement not covered" >return this._type}<span class="fstat-no" title="function not covered" ></span>ge</span>t suites(){<span class="cstat-no" title="statement not covered" >return this._entries.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type!=="test")</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t tests(){<span class="cstat-no" title="statement not covered" >return this._entries.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type==="test")</span>}<span class="fstat-no" title="function not covered" ></span>en</span>tries(){<span class="cstat-no" title="statement not covered" >return this._entries}<span class="fstat-no" title="function not covered" ></span>al</span>lTests(){const t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const i of s.entries())<span class="cstat-no" title="statement not covered" >i.type==="test"?t.push(i):e(i)}</span></span>;<span class="cstat-no" title="statement not covered" ></span>return e(this),t}<span class="fstat-no" title="function not covered" ></span>ti</span>tlePath(){const t=<span class="cstat-no" title="statement not covered" >this.parent?this.parent.titlePath():[];<span class="cstat-no" title="statement not covered" ></span>return(this.title||this._type!=="describe")&amp;&amp;t.push(this.title),t}<span class="fstat-no" title="function not covered" ></span>pr</span>oject(){var t;<span class="cstat-no" title="statement not covered" >return this._project??((t=this.parent)==null?void 0:t.project())}<span class="fstat-no" title="function not covered" ></span>_a</span>ddTest(t){<span class="cstat-no" title="statement not covered" >t.parent=this,this._entries.push(t)}<span class="fstat-no" title="function not covered" ></span>_a</span>ddSuite(t){<span class="cstat-no" title="statement not covered" >t.parent=this,this._entries.push(t)}</span>}class Wt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s,i){<span class="cstat-no" title="statement not covered" >this.fn=<span class="fstat-no" title="function not covered" >()</span>=&gt;{},this.results=[],this.type="test",this.expectedStatus="passed",this.timeout=0,this.annotations=[],this.retries=0,this.tags=[],this.repeatEachIndex=0,this.id=t,this.title=e,this.location=s,this.repeatEachIndex=i}<span class="fstat-no" title="function not covered" ></span>ti</span>tlePath(){const t=<span class="cstat-no" title="statement not covered" >this.parent?this.parent.titlePath():[];<span class="cstat-no" title="statement not covered" ></span>return t.push(this.title),t}<span class="fstat-no" title="function not covered" ></span>ou</span>tcome(){<span class="cstat-no" title="statement not covered" >return Vt(this)}<span class="fstat-no" title="function not covered" ></span>ok</span>(){const t=<span class="cstat-no" title="statement not covered" >this.outcome();<span class="cstat-no" title="statement not covered" ></span>return t==="expected"||t==="flaky"||t==="skipped"}<span class="fstat-no" title="function not covered" ></span>_c</span>reateTestResult(t){const e=<span class="cstat-no" title="statement not covered" >new zt(this.results.length,t);<span class="cstat-no" title="statement not covered" ></span>return this.results.push(e),e}</span>}class Ut{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s){<span class="cstat-no" title="statement not covered" >this.duration=-1,this.steps=[],this._startTime=0,this.title=t.title,this.category=t.category,this.location=s,this.parent=e,this._startTime=t.startTime}<span class="fstat-no" title="function not covered" ></span>ti</span>tlePath(){var e;<span class="cstat-no" title="statement not covered" >return[...((e=this.parent)==null?void 0:e.titlePath())||[],this.title]}<span class="fstat-no" title="function not covered" ></span>ge</span>t startTime(){<span class="cstat-no" title="statement not covered" >return new Date(this._startTime)}<span class="fstat-no" title="function not covered" ></span>se</span>t startTime(t){<span class="cstat-no" title="statement not covered" >this._startTime=+t}</span>}class zt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.parallelIndex=-1,this.workerIndex=-1,this.duration=-1,this.stdout=[],this.stderr=[],this.attachments=[],this.status="skipped",this.steps=[],this.errors=[],this._stepMap=new Map,this._startTime=0,this.retry=t,this._id=e}<span class="fstat-no" title="function not covered" ></span>se</span>tStartTimeNumber(t){<span class="cstat-no" title="statement not covered" >this._startTime=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t startTime(){<span class="cstat-no" title="statement not covered" >return new Date(this._startTime)}<span class="fstat-no" title="function not covered" ></span>se</span>t startTime(t){<span class="cstat-no" title="statement not covered" >this._startTime=+t}</span>}const Kt=<span class="cstat-no" title="statement not covered" >{forbidOnly:!1,fullyParallel:!1,globalSetup:null,globalTeardown:null,globalTimeout:0,grep:/.*/,grepInvert:null,maxFailures:0,metadata:{},preserveOutput:"always",projects:[],reporter:[[At.CI?"dot":"list"]],reportSlowTests:{max:5,threshold:15e3},configFile:"",rootDir:"",quiet:!1,shard:null,updateSnapshots:"missing",version:"",workers:0,webServer:null};</span>function <span class="fstat-no" title="function not covered" >Q(</span>r){<span class="cstat-no" title="statement not covered" >return r.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.s?t.s:new RegExp(t.r.source,t.r.flags))</span>}</span>function <span class="fstat-no" title="function not covered" >Vt(</span>r){let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const i of r.results)<span class="cstat-no" title="statement not covered" >i.status==="interrupted"||(i.status==="skipped"&amp;&amp;r.expectedStatus==="skipped"?++t:i.status==="skipped"||(i.status===r.expectedStatus?++e:++s));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e===0&amp;&amp;s===0?"skipped":s===0?"expected":e===0&amp;&amp;t===0?"unexpected":"flaky"}</span>class at{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,s,i,d){<span class="cstat-no" title="statement not covered" >this._treeItemById=new Map,this._treeItemByTestId=new Map;c</span>onst a=<span class="cstat-no" title="statement not covered" >i&amp;&amp;[...i.values()].some(Boolean);<span class="cstat-no" title="statement not covered" ></span>this.pathSeparator=d,this.rootItem={kind:"group",subKind:"folder",id:t,title:"",location:{file:"",line:0,column:0},duration:0,parent:void 0,children:[],status:"none",hasLoadErrors:!1},this._treeItemById.set(t,this.rootItem);c</span>onst f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,m,u)=&gt;{<span class="cstat-no" title="statement not covered" >for(const g of m.suites){const k=<span class="cstat-no" title="statement not covered" >g.title||"&lt;anonymous&gt;";</span>let l=<span class="cstat-no" title="statement not covered" >u.children.find(<span class="fstat-no" title="function not covered" >p=</span>&gt;<span class="cstat-no" title="statement not covered" >p.kind==="group"&amp;&amp;p.title===k)</span>;<span class="cstat-no" title="statement not covered" ></span>l||(l={kind:"group",subKind:"describe",id:"suite:"+m.titlePath().join("")+""+k,title:k,location:g.location,duration:0,parent:u,children:[],status:"none",hasLoadErrors:!1},this._addChild(u,l)),f(n,g,l)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const g of m.tests){const k=<span class="cstat-no" title="statement not covered" >g.title;</span>let l=<span class="cstat-no" title="statement not covered" >u.children.find(<span class="fstat-no" title="function not covered" >I=</span>&gt;<span class="cstat-no" title="statement not covered" >I.kind!=="group"&amp;&amp;I.title===k)</span>;<span class="cstat-no" title="statement not covered" ></span>l||(l={kind:"case",id:"test:"+g.titlePath().join(""),title:k,parent:u,children:[],tests:[],location:g.location,duration:0,status:"none",project:void 0,test:void 0,tags:g.tags},this._addChild(u,l));c</span>onst p=<span class="cstat-no" title="statement not covered" >g.results[0];</span>let x=<span class="cstat-no" title="statement not covered" >"none";<span class="cstat-no" title="statement not covered" ></span>(p==null?void 0:p[H])==="scheduled"?x="scheduled":(p==null?void 0:p[H])==="running"?x="running":(p==null?void 0:p.status)==="skipped"?x="skipped":(p==null?void 0:p.status)==="interrupted"?x="none":p&amp;&amp;g.outcome()!=="expected"?x="failed":p&amp;&amp;g.outcome()==="expected"&amp;&amp;(x="passed"),l.tests.push(g);c</span>onst E=<span class="cstat-no" title="statement not covered" >{kind:"test",id:g.id,title:n.name,location:g.location,test:g,parent:l,children:[],status:x,duration:g.results.length?Math.max(0,g.results[0].duration):0,project:n};<span class="cstat-no" title="statement not covered" ></span>this._addChild(l,E),this._treeItemByTestId.set(g.id,E),l.duration=l.children.reduce(<span class="fstat-no" title="function not covered" >(I</span>,T)=&gt;<span class="cstat-no" title="statement not covered" >I+T.duration,</span>0)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>for(const n of(e==null?void 0:e.suites)||[])<span class="cstat-no" title="statement not covered" >if(!(a&amp;&amp;!i.get(n.title)))<span class="cstat-no" title="statement not covered" >for(const m of n.suites){const u=<span class="cstat-no" title="statement not covered" >this._fileItem(m.location.file.split(d),!0);<span class="cstat-no" title="statement not covered" ></span>f(n.project(),m,u)}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(const n of s){<span class="cstat-no" title="statement not covered" >if(!n.location)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst m=<span class="cstat-no" title="statement not covered" >this._fileItem(n.location.file.split(d),!0);<span class="cstat-no" title="statement not covered" ></span>m.hasLoadErrors=!0}</span>}<span class="fstat-no" title="function not covered" ></span>_a</span>ddChild(t,e){<span class="cstat-no" title="statement not covered" >t.children.push(e),e.parent=t,this._treeItemById.set(e.id,e)}<span class="fstat-no" title="function not covered" ></span>fi</span>lterTree(t,e,s){const i=<span class="cstat-no" title="statement not covered" >t.trim().toLowerCase().split(" "),</span>d=<span class="cstat-no" title="statement not covered" >[...e.values()].some(Boolean),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;{const m=<span class="cstat-no" title="statement not covered" >[...n.tests[0].titlePath(),...n.tests[0].tags].join(" ").toLowerCase();<span class="cstat-no" title="statement not covered" ></span>return!i.every(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >m.includes(u))</span>&amp;&amp;!n.tests.some(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >s==null?void 0:s.has(u.id))</span>?!1:(n.children=n.children.filter(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >!d||(s==null?void 0:s.has(u.test.id))||e.get(u.status))</span>,n.tests=n.children.map(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >u.test)</span>,!!n.children.length)}</span>,</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;{const m=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const u of n.children)<span class="cstat-no" title="statement not covered" >u.kind==="case"?a(u)&amp;&amp;m.push(u):(f(u),(u.children.length||u.hasLoadErrors)&amp;&amp;m.push(u));<span class="cstat-no" title="statement not covered" >n</span></span>.children=m}</span>;<span class="cstat-no" title="statement not covered" ></span>f(this.rootItem)}<span class="fstat-no" title="function not covered" ></span>_f</span>ileItem(t,e){<span class="cstat-no" title="statement not covered" >if(t.length===0)<span class="cstat-no" title="statement not covered" >return this.rootItem;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t.join(this.pathSeparator),</span>i=<span class="cstat-no" title="statement not covered" >this._treeItemById.get(s);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst d=<span class="cstat-no" title="statement not covered" >this._fileItem(t.slice(0,t.length-1),!1),</span>a=<span class="cstat-no" title="statement not covered" >{kind:"group",subKind:e?"file":"folder",id:s,title:t[t.length-1],location:{file:s,line:0,column:0},duration:0,parent:d,children:[],status:"none",hasLoadErrors:!1};<span class="cstat-no" title="statement not covered" ></span>return this._addChild(d,a),a}<span class="fstat-no" title="function not covered" ></span>so</span>rtAndPropagateStatus(){<span class="cstat-no" title="statement not covered" >ht(this.rootItem)}<span class="fstat-no" title="function not covered" ></span>fl</span>attenForSingleProject(){const t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.kind==="case"&amp;&amp;e.children.length===1?(e.project=e.children[0].project,e.test=e.children[0].test,e.children=[],this._treeItemByTestId.set(e.test.id,e)):e.children.forEach(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>t(this.rootItem)}<span class="fstat-no" title="function not covered" ></span>sh</span>ortenRoot(){let t=<span class="cstat-no" title="statement not covered" >this.rootItem;<span class="cstat-no" title="statement not covered" ></span>for(;t.children.length===1&amp;&amp;t.children[0].kind==="group"&amp;&amp;t.children[0].subKind==="folder";)<span class="cstat-no" title="statement not covered" >t=t.children[0];<span class="cstat-no" title="statement not covered" >t</span></span>.location=this.rootItem.location,this.rootItem=t}<span class="fstat-no" title="function not covered" ></span>te</span>stIds(){const t=<span class="cstat-no" title="statement not covered" >new Set,</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.kind==="case"&amp;&amp;s.tests.forEach(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t.add(i.id))</span>,s.children.forEach(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return e(this.rootItem),t}<span class="fstat-no" title="function not covered" ></span>fi</span>leNames(){const t=<span class="cstat-no" title="statement not covered" >new Set,</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.kind==="group"&amp;&amp;s.subKind==="file"?t.add(s.id):s.children.forEach(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return e(this.rootItem),[...t]}<span class="fstat-no" title="function not covered" ></span>fl</span>atTreeItems(){const t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.push(s),s.children.forEach(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return e(this.rootItem),t}<span class="fstat-no" title="function not covered" ></span>tr</span>eeItemById(t){<span class="cstat-no" title="statement not covered" >return this._treeItemById.get(t)}<span class="fstat-no" title="function not covered" ></span>co</span>llectTestIds(t){<span class="cstat-no" title="statement not covered" >return t?$t(t):new Set}</span>}function <span class="fstat-no" title="function not covered" >ht(</span>r){<span class="cstat-no" title="statement not covered" >for(const a of r.children)<span class="cstat-no" title="statement not covered" >ht(a);<span class="cstat-no" title="statement not covered" >r</span></span>.kind==="group"&amp;&amp;r.children.sort(<span class="fstat-no" title="function not covered" >(a</span>,f)=&gt;<span class="cstat-no" title="statement not covered" >a.location.file.localeCompare(f.location.file)||a.location.line-f.location.line)</span>;l</span>et t=<span class="cstat-no" title="statement not covered" >r.children.length&gt;0,</span>e=<span class="cstat-no" title="statement not covered" >r.children.length&gt;0,</span>s=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >!1,</span>d=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const a of r.children)<span class="cstat-no" title="statement not covered" >e=e&amp;&amp;a.status==="skipped",t=t&amp;&amp;(a.status==="passed"||a.status==="skipped"),s=s||a.status==="failed",i=i||a.status==="running",d=d||a.status==="scheduled";<span class="cstat-no" title="statement not covered" >i</span></span>?r.status="running":d?r.status="scheduled":s?r.status="failed":e?r.status="skipped":t&amp;&amp;(r.status="passed")}</span>function <span class="fstat-no" title="function not covered" >$t(</span>r){const t=<span class="cstat-no" title="statement not covered" >new Set,</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s=</span>&gt;{var i;<span class="cstat-no" title="statement not covered" >s.kind==="case"?s.tests.map(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >d.id)</span>.forEach(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >t.add(d))</span>:s.kind==="test"?t.add(s.id):(i=s.children)==null||i.forEach(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>return e(r),t}</span>const H=<span class="cstat-no" title="statement not covered" >Symbol("statusEx");</span>class qt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >F(this,"rootSuite");<span class="cstat-no" title="statement not covered" >F</span>(this,"config");<span class="cstat-no" title="statement not covered" >F</span>(this,"loadErrors",[]);<span class="cstat-no" title="statement not covered" >F</span>(this,"progress",{total:0,passed:0,failed:0,skipped:0});<span class="cstat-no" title="statement not covered" >F</span>(this,"_receiver");<span class="cstat-no" title="statement not covered" >F</span>(this,"_lastRunReceiver");<span class="cstat-no" title="statement not covered" >F</span>(this,"_lastRunTestCount",0);<span class="cstat-no" title="statement not covered" >F</span>(this,"_options");<span class="cstat-no" title="statement not covered" >F</span>(this,"_testResultsSnapshot");<span class="cstat-no" title="statement not covered" >t</span>his._receiver=new et(this._createReporter(),{mergeProjects:!0,mergeTestCases:!0,resolvePath:<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >e+t.pathSeparator+s,</span>clearPreviousResultsWhenTestBegins:!0}),this._options=t}<span class="fstat-no" title="function not covered" ></span>_c</span>reateReporter(){<span class="cstat-no" title="statement not covered" >return{version:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"v2",</span>onConfigure:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.config=t,this._lastRunReceiver=new et({onBegin:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._lastRunTestCount=e.allTests().length,this._lastRunReceiver=void 0}</span>},{mergeProjects:!0,mergeTestCases:!1,resolvePath:<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >e+this._options.pathSeparator+s}</span>)}</span>,onBegin:<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >if(this.rootSuite||(this.rootSuite=t),this._testResultsSnapshot){<span class="cstat-no" title="statement not covered" >for(const s of this.rootSuite.allTests())<span class="cstat-no" title="statement not covered" >s.results=((e=this._testResultsSnapshot)==null?void 0:e.get(s.id))||s.results;<span class="cstat-no" title="statement not covered" >t</span></span>his._testResultsSnapshot=void 0}<span class="cstat-no" title="statement not covered" ></span>t</span>his.progress.total=this._lastRunTestCount,this.progress.passed=0,this.progress.failed=0,this.progress.skipped=0,this._options.onUpdate(!0)}</span>,onEnd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._options.onUpdate(!0)}</span>,onTestBegin:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >e[H]="running",this._options.onUpdate()}</span>,onTestEnd:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t.outcome()==="skipped"?++this.progress.skipped:t.outcome()==="unexpected"?++this.progress.failed:++this.progress.passed,e[H]=e.status,this._options.onUpdate()}</span>,onError:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this._handleOnError(t),</span>printsToStdio:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1,</span>onStdOut:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},onStdErr:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},onExit:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},onStepBegin:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},onStepEnd:<span class="fstat-no" title="function not covered" >()</span>=&gt;{}}}<span class="fstat-no" title="function not covered" ></span>pr</span>ocessGlobalReport(t){const e=<span class="cstat-no" title="statement not covered" >new et({onConfigure:<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.config=s}</span>,onError:<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >this._handleOnError(s)}</span>);<span class="cstat-no" title="statement not covered" ></span>for(const s of t)<span class="cstat-no" title="statement not covered" >e.dispatch(s)}<span class="fstat-no" title="function not covered" ></span></span>pr</span>ocessListReport(t){var s;const e=<span class="cstat-no" title="statement not covered" >((s=this.rootSuite)==null?void 0:s.allTests())||[];<span class="cstat-no" title="statement not covered" ></span>this._testResultsSnapshot=new Map(e.map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >[i.id,i.results])</span>),this._receiver.reset();<span class="cstat-no" title="statement not covered" >f</span>or(const i of t)<span class="cstat-no" title="statement not covered" >this._receiver.dispatch(i)}<span class="fstat-no" title="function not covered" ></span></span>pr</span>ocessTestReportEvent(t){var e,s,i;<span class="cstat-no" title="statement not covered" >(s=(e=this._lastRunReceiver)==null?void 0:e.dispatch(t))==null||s.catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;{}),(i=this._receiver.dispatch(t))==null||i.catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;{})}<span class="fstat-no" title="function not covered" ></span>_h</span>andleOnError(t){var e,s;<span class="cstat-no" title="statement not covered" >this.loadErrors.push(t),(s=(e=this._options).onError)==null||s.call(e,t),this._options.onUpdate()}<span class="fstat-no" title="function not covered" ></span>as</span>Model(){<span class="cstat-no" title="statement not covered" >return{rootSuite:this.rootSuite||new q("","root"),config:this.config,loadErrors:this.loadErrors,progress:this.progress}}</span>}const Ht=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>source:r})=&gt;{const[t,e]=<span class="cstat-no" title="statement not covered" >Tt(),</span>[s,i]=<span class="cstat-no" title="statement not covered" >V.useState(kt()),</span>[d]=<span class="cstat-no" title="statement not covered" >V.useState(jt(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >import("./assets/xtermModule-BeNbaIVa.js"),</span>__vite__mapDeps([0,1]),import.meta.url).then(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >f.default)</span>),</span>a=<span class="cstat-no" title="statement not covered" >V.useRef(null);<span class="cstat-no" title="statement not covered" ></span>return V.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >yt(i),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Et(i))</span></span>,[]),V.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const f=<span class="cstat-no" title="statement not covered" >r.write,</span>n=<span class="cstat-no" title="statement not covered" >r.clear;<span class="cstat-no" title="statement not covered" ></span>return(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const{Terminal:m,FitAddon:u}=<span class="cstat-no" title="statement not covered" >await d,</span>g=<span class="cstat-no" title="statement not covered" >e.current;<span class="cstat-no" title="statement not covered" ></span>if(!g)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst k=<span class="cstat-no" title="statement not covered" >s==="dark-mode"?Qt:Yt;<span class="cstat-no" title="statement not covered" ></span>if(a.current&amp;&amp;a.current.terminal.options.theme===k)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >a</span></span>.current&amp;&amp;(g.textContent="");c</span>onst l=<span class="cstat-no" title="statement not covered" >new m({convertEol:!0,fontSize:13,scrollback:1e4,fontFamily:"var(--vscode-editor-font-family)",theme:k}),</span>p=<span class="cstat-no" title="statement not covered" >new u;<span class="cstat-no" title="statement not covered" ></span>l.loadAddon(p);<span class="cstat-no" title="statement not covered" >f</span>or(const x of r.pending)<span class="cstat-no" title="statement not covered" >l.write(x);<span class="cstat-no" title="statement not covered" >r</span></span>.write=<span class="fstat-no" title="function not covered" >x=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.pending.push(x),l.write(x)}</span>,r.clear=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.pending=[],l.clear()}</span>,l.open(g),p.fit(),a.current={terminal:l,fitAddon:p}}</span>)(),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r.clear=n,r.write=f}</span>}</span>,[d,a,e,r,s]),V.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >a.current&amp;&amp;(a.current.fitAddon.fit(),r.resize(a.current.terminal.cols,a.current.terminal.rows))}</span>,250)}</span>,[t,r]),o.jsx("div",{"data-testid":"output",className:"xterm-wrapper",style:{flex:"auto"},ref:e})}</span>,</span>Yt=<span class="cstat-no" title="statement not covered" >{foreground:"#383a42",background:"#fafafa",cursor:"#383a42",black:"#000000",red:"#e45649",green:"#50a14f",yellow:"#c18401",blue:"#4078f2",magenta:"#a626a4",cyan:"#0184bc",white:"#a0a0a0",brightBlack:"#000000",brightRed:"#e06c75",brightGreen:"#98c379",brightYellow:"#d19a66",brightBlue:"#4078f2",brightMagenta:"#a626a4",brightCyan:"#0184bc",brightWhite:"#383a42",selectionBackground:"#d7d7d7",selectionForeground:"#383a42"},</span>Qt=<span class="cstat-no" title="statement not covered" >{foreground:"#f8f8f2",background:"#1e1e1e",cursor:"#f8f8f0",black:"#000000",red:"#ff5555",green:"#50fa7b",yellow:"#f1fa8c",blue:"#bd93f9",magenta:"#ff79c6",cyan:"#8be9fd",white:"#bfbfbf",brightBlack:"#4d4d4d",brightRed:"#ff6e6e",brightGreen:"#69ff94",brightYellow:"#ffffa5",brightBlue:"#d6acff",brightMagenta:"#ff92df",brightCyan:"#a4ffff",brightWhite:"#e6e6e6",selectionBackground:"#44475a",selectionForeground:"#f8f8f2"},</span>st=<span class="cstat-no" title="statement not covered" >navigator.userAgent.toLowerCase().includes("windows")?"\\":"/",</span>Xt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>title:r,children:t,setExpanded:e,expanded:s,expandOnTitleClick:i})=&gt;<span class="cstat-no" title="statement not covered" >o.jsxs("div",{className:"expandable"+(s?" expanded":""),children:[o.jsxs("div",{className:"expandable-title",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i&amp;&amp;e(!s),</span>children:[o.jsx("div",{className:"codicon codicon-"+(s?"chevron-down":"chevron-right"),style:{cursor:"pointer",color:"var(--vscode-foreground)",marginLeft:"5px"},onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!i&amp;&amp;e(!s)}</span>),r]}),s&amp;&amp;o.jsx("div",{style:{marginLeft:25},children:t})]}),</span></span>Gt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>filterText:r,setFilterText:t,statusFilters:e,setStatusFilters:s,projectFilters:i,setProjectFilters:d,testModel:a,runTests:f})=&gt;{const[n,m]=<span class="cstat-no" title="statement not covered" >h.useState(!1),</span>u=<span class="cstat-no" title="statement not covered" >h.useRef(null);<span class="cstat-no" title="statement not covered" ></span>h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var l;<span class="cstat-no" title="statement not covered" >(l=u.current)==null||l.focus()}</span>,[]);c</span>onst g=<span class="cstat-no" title="statement not covered" >[...e.entries()].filter(<span class="fstat-no" title="function not covered" >([</span>l,p])=&gt;<span class="cstat-no" title="statement not covered" >p)</span>.map(<span class="fstat-no" title="function not covered" >([</span>l])=&gt;<span class="cstat-no" title="statement not covered" >l)</span>.join(" ")||"all",</span>k=<span class="cstat-no" title="statement not covered" >[...i.entries()].filter(<span class="fstat-no" title="function not covered" >([</span>l,p])=&gt;<span class="cstat-no" title="statement not covered" >p)</span>.map(<span class="fstat-no" title="function not covered" >([</span>l])=&gt;<span class="cstat-no" title="statement not covered" >l)</span>.join(" ")||"all";<span class="cstat-no" title="statement not covered" ></span>return o.jsxs("div",{className:"filters",children:[o.jsx(Xt,{expanded:n,setExpanded:m,title:o.jsx("input",{ref:u,type:"search",placeholder:"Filter (e.g. text, @tag)",spellCheck:!1,value:r,onChange:<span class="fstat-no" title="function not covered" >l=</span>&gt;{<span class="cstat-no" title="statement not covered" >t(l.target.value)}</span>,onKeyDown:<span class="fstat-no" title="function not covered" >l=</span>&gt;{<span class="cstat-no" title="statement not covered" >l.key==="Enter"&amp;&amp;f()}</span>})}),o.jsxs("div",{className:"filter-summary",title:"Status: "+g+`</span></span>
Projects: `+k,onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >m(!n),</span>children:[o.jsx("span",{className:"filter-label",children:"Status:"})," ",g,o.jsx("span",{className:"filter-label",children:"Projects:"})," ",k]}),n&amp;&amp;o.jsxs("div",{className:"hbox",style:{marginLeft:14,maxHeight:200,overflowY:"auto"},children:[o.jsx("div",{className:"filter-list",children:[...e.entries()].map(<span class="fstat-no" title="function not covered" >([</span>l,p])=&gt;<span class="cstat-no" title="statement not covered" >o.jsx("div",{className:"filter-entry",children:o.jsxs("label",{children:[o.jsx("input",{type:"checkbox",checked:p,onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;{const x=<span class="cstat-no" title="statement not covered" >new Map(e);<span class="cstat-no" title="statement not covered" ></span>x.set(l,!x.get(l)),s(x)}</span>}),o.jsx("div",{children:l})]})}))</span>}),o.jsx("div",{className:"filter-list",children:[...i.entries()].map(<span class="fstat-no" title="function not covered" >([</span>l,p])=&gt;<span class="cstat-no" title="statement not covered" >o.jsx("div",{className:"filter-entry",children:o.jsxs("label",{children:[o.jsx("input",{type:"checkbox",checked:p,onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;{var I;const x=<span class="cstat-no" title="statement not covered" >new Map(i);<span class="cstat-no" title="statement not covered" ></span>x.set(l,!x.get(l)),d(x);c</span>onst E=<span class="cstat-no" title="statement not covered" >(I=a==null?void 0:a.config)==null?void 0:I.configFile;<span class="cstat-no" title="statement not covered" ></span>E&amp;&amp;ut.setObject(E+":projects",[...x.entries()].filter(<span class="fstat-no" title="function not covered" >([</span>T,U])=&gt;<span class="cstat-no" title="statement not covered" >U)</span>.map(<span class="fstat-no" title="function not covered" >([</span>T])=&gt;<span class="cstat-no" title="statement not covered" >T)</span>)}</span>}),o.jsx("div",{children:l||"untitled"})]})}))</span>})]})]})},Jt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tag:r,style:t,onClick:e})=&gt;<span class="cstat-no" title="statement not covered" >o.jsx("span",{className:`tag tag-color-${Zt(r)}`,onClick:e,style:{margin:"6px 0 0 6px",...t},title:`Click to filter by tag: ${r}`,children:r});</span></span>function <span class="fstat-no" title="function not covered" >Zt(</span>r){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;r.length;e++)<span class="cstat-no" title="statement not covered" >t=r.charCodeAt(e)+((t&lt;&lt;8)-t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Math.abs(t%6)}</span>const te=<span class="cstat-no" title="statement not covered" >Bt,</span>ee=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>filterText:r,testModel:t,testServerConnection:e,testTree:s,runTests:i,runningState:d,watchAll:a,watchedTreeIds:f,setWatchedTreeIds:n,isLoading:m,onItemSelected:u,requestedCollapseAllCount:g,setFilterText:k})=&gt;{const[l,p]=<span class="cstat-no" title="statement not covered" >h.useState({expandedItems:new Map}),</span>[x,E]=<span class="cstat-no" title="statement not covered" >h.useState(),</span>[I,T]=<span class="cstat-no" title="statement not covered" >h.useState(g);<span class="cstat-no" title="statement not covered" ></span>h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(I!==g){<span class="cstat-no" title="statement not covered" >l.expandedItems.clear();<span class="cstat-no" title="statement not covered" >f</span>or(const b of s.flatTreeItems())<span class="cstat-no" title="statement not covered" >l.expandedItems.set(b.id,!1);<span class="cstat-no" title="statement not covered" >T</span></span>(g),E(void 0),p({...l});<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!d||d.itemSelectedByUser)<span class="cstat-no" title="statement not covered" >return;l</span></span>et c;const j=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >b=</span>&gt;{var C;<span class="cstat-no" title="statement not covered" >b.children.forEach(j),!c&amp;&amp;b.status==="failed"&amp;&amp;(b.kind==="test"&amp;&amp;d.testIds.has(b.test.id)||b.kind==="case"&amp;&amp;d.testIds.has((C=b.tests[0])==null?void 0:C.id))&amp;&amp;(c=b)}</span>;<span class="cstat-no" title="statement not covered" ></span>j(s.rootItem),c&amp;&amp;E(c.id)}</span>,[d,E,s,I,T,g,l,p]);c</span>onst{selectedTreeItem:U}=<span class="cstat-no" title="statement not covered" >h.useMemo(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return{selectedTreeItem:void 0};c</span></span>onst c=<span class="cstat-no" title="statement not covered" >x?s.treeItemById(x):void 0;</span>let j;<span class="cstat-no" title="statement not covered" >c&amp;&amp;(j={file:c.location.file,line:c.location.line,source:{errors:t.loadErrors.filter(<span class="fstat-no" title="function not covered" >C=</span>&gt;{var $;<span class="cstat-no" title="statement not covered" >return(($=C.location)==null?void 0:$.file)===c.location.file}</span>).map(<span class="fstat-no" title="function not covered" >C=</span>&gt;(<span class="cstat-no" title="statement not covered" >{line:C.location.line,message:C.message})</span>),content:void 0}});l</span>et b;<span class="cstat-no" title="statement not covered" >return(c==null?void 0:c.kind)==="test"?b=c.test:(c==null?void 0:c.kind)==="case"&amp;&amp;c.tests.length===1&amp;&amp;(b=c.tests[0]),u({treeItem:c,testCase:b,testFile:j}),{selectedTreeItem:c}}</span>,[u,x,t,s]);<span class="cstat-no" title="statement not covered" ></span>h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!m)<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >e==null||e.watchNoReply({fileNames:s.fileNames()});e</span>lse{const c=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const j of f.value){const b=<span class="cstat-no" title="statement not covered" >s.treeItemById(j),</span>C=<span class="cstat-no" title="statement not covered" >b==null?void 0:b.location.file;<span class="cstat-no" title="statement not covered" ></span>C&amp;&amp;c.add(C)}<span class="cstat-no" title="statement not covered" ></span>e</span>==null||e.watchNoReply({fileNames:[...c]})}</span>}</span></span>,[m,s,a,f,e]);c</span>onst O=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >c=</span>&gt;{<span class="cstat-no" title="statement not covered" >E(c.id),i("bounce-if-busy",s.collectTestIds(c))}</span>,</span>G=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(c</span>,j)=&gt;{<span class="cstat-no" title="statement not covered" >if(c.preventDefault(),c.stopPropagation(),c.metaKey||c.ctrlKey){const b=<span class="cstat-no" title="statement not covered" >r.split(" ");<span class="cstat-no" title="statement not covered" ></span>b.includes(j)?k(b.filter(<span class="fstat-no" title="function not covered" >C=</span>&gt;<span class="cstat-no" title="statement not covered" >C!==j)</span>.join(" ").trim()):k((r+" "+j).trim())}</span>else <span class="cstat-no" title="statement not covered" >k((r.split(" ").filter(<span class="fstat-no" title="function not covered" >b=</span>&gt;<span class="cstat-no" title="statement not covered" >!b.startsWith("@"))</span>.join(" ")+" "+j).trim())}</span></span>;<span class="cstat-no" title="statement not covered" ></span>return o.jsx(te,{name:"tests",treeState:l,setTreeState:p,rootItem:s.rootItem,dataTestId:"test-tree",render:<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >o.jsxs("div",{className:"hbox ui-mode-list-item",children:[o.jsxs("div",{className:"ui-mode-list-item-title",children:[o.jsx("span",{title:c.title,children:c.title}),c.kind==="case"?c.tags.map(<span class="fstat-no" title="function not covered" >j=</span>&gt;<span class="cstat-no" title="statement not covered" >o.jsx(Jt,{tag:j.slice(1),onClick:<span class="fstat-no" title="function not covered" >b=</span>&gt;<span class="cstat-no" title="statement not covered" >G(b,j)}</span>,j))</span>:null]}),!!c.duration&amp;&amp;c.status!=="skipped"&amp;&amp;o.jsx("div",{className:"ui-mode-list-item-time",children:It(c.duration)}),o.jsxs(X,{noMinHeight:!0,noShadow:!0,children:[o.jsx(N,{icon:"play",title:"Run",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >O(c),</span>disabled:!!d}),o.jsx(N,{icon:"go-to-file",title:"Open in VS Code",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e==null?void 0:e.openNoReply({location:c.location}),</span>style:c.kind==="group"&amp;&amp;c.subKind==="folder"?{visibility:"hidden"}:{}}),!a&amp;&amp;o.jsx(N,{icon:"eye",title:"Watch",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >f.value.has(c.id)?f.value.delete(c.id):f.value.add(c.id),n({...f})}</span>,toggled:f.value.has(c.id)})]})]}),</span>icon:<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >Rt(c.status),</span>selectedItem:U,onAccepted:O,onSelected:<span class="fstat-no" title="function not covered" >c=</span>&gt;{<span class="cstat-no" title="statement not covered" >d&amp;&amp;(d.itemSelectedByUser=!0),E(c.id)}</span>,isError:<span class="fstat-no" title="function not covered" >c=</span>&gt;<span class="cstat-no" title="statement not covered" >c.kind==="group"?c.hasLoadErrors:!1,</span>autoExpandDepth:r?5:1,noItemsMessage:m?"Loading":"No tests"})}</span>;</span>function <span class="fstat-no" title="function not covered" >se(</span>r){<span class="cstat-no" title="statement not covered" >return`.playwright-artifacts-${r}`}</span>const ie=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>item:r,rootDir:t})=&gt;{var k;const[e,s]=<span class="cstat-no" title="statement not covered" >h.useState(),</span>[i,d]=<span class="cstat-no" title="statement not covered" >h.useState(0),</span>a=<span class="cstat-no" title="statement not covered" >h.useRef(null),</span>{outputDir:f}=<span class="cstat-no" title="statement not covered" >h.useMemo(<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{outputDir:r.testCase?re(r.testCase):void 0})</span>,[r]),</span>[n,m]=<span class="cstat-no" title="statement not covered" >h.useState(),</span>u=<span class="cstat-no" title="statement not covered" >h.useCallback(<span class="fstat-no" title="function not covered" >l=</span>&gt;<span class="cstat-no" title="statement not covered" >m(nt(l)),</span>[m]),</span>g=<span class="cstat-no" title="statement not covered" >n?e==null?void 0:e.model.actions.find(<span class="fstat-no" title="function not covered" >l=</span>&gt;<span class="cstat-no" title="statement not covered" >nt(l)===n)</span>:void 0;<span class="cstat-no" title="statement not covered" ></span>return h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var E,I;<span class="cstat-no" title="statement not covered" >a.current&amp;&amp;clearTimeout(a.current);c</span>onst l=<span class="cstat-no" title="statement not covered" >(E=r.testCase)==null?void 0:E.results[0];<span class="cstat-no" title="statement not covered" ></span>if(!l){<span class="cstat-no" title="statement not covered" >s(void 0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst p=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.duration&gt;=0&amp;&amp;l.attachments.find(<span class="fstat-no" title="function not covered" >T=</span>&gt;<span class="cstat-no" title="statement not covered" >T.name==="trace")</span>;<span class="cstat-no" title="statement not covered" ></span>if(p&amp;&amp;p.path){<span class="cstat-no" title="statement not covered" >lt(p.path).then(<span class="fstat-no" title="function not covered" >T=</span>&gt;<span class="cstat-no" title="statement not covered" >s({model:T,isLive:!1}))</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!f){<span class="cstat-no" title="statement not covered" >s(void 0);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>c</span>onst x=<span class="cstat-no" title="statement not covered" >`${f}/${se(l.workerIndex)}/traces/${(I=r.testCase)==null?void 0:I.id}.json`;<span class="cstat-no" title="statement not covered" ></span>return a.current=setTimeout(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >try{const T=<span class="cstat-no" title="statement not covered" >await lt(x);<span class="cstat-no" title="statement not covered" ></span>s({model:T,isLive:!0})}</span>catch{<span class="cstat-no" title="statement not covered" >s(void 0)}</span>finally{<span class="cstat-no" title="statement not covered" >d(i+1)}</span>}</span>,500),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >a.current&amp;&amp;clearTimeout(a.current)}</span>}</span>,[f,r,s,i,d]),o.jsx(Ct,{model:e==null?void 0:e.model,showSourcesFirst:!0,rootDir:t,initialSelection:g,onSelectionChanged:u,fallbackLocation:r.testFile,isLive:e==null?void 0:e.isLive,status:(k=r.treeItem)==null?void 0:k.status},"workbench")}</span>,</span>re=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;{var t;<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >r.parent;</span>e;e=e.parent)<span class="cstat-no" title="statement not covered" >if(e.project())<span class="cstat-no" title="statement not covered" >return(t=e.project())==null?void 0:t.outputDir}</span></span></span>;</span>async function <span class="fstat-no" title="function not covered" >lt(</span>r){const t=<span class="cstat-no" title="statement not covered" >new URLSearchParams;<span class="cstat-no" title="statement not covered" ></span>t.set("trace",r);c</span>onst s=<span class="cstat-no" title="statement not covered" >await(await fetch(`contexts?${t.toString()}`)).json();<span class="cstat-no" title="statement not covered" ></span>return new Nt(s)}</span>let ct=<span class="cstat-no" title="statement not covered" >{cols:80,rows:24};</span>const A=<span class="cstat-no" title="statement not covered" >{pending:[],clear:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},write:<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >A.pending.push(r),</span>resize:<span class="fstat-no" title="function not covered" >()</span>=&gt;{}},</span>D=<span class="cstat-no" title="statement not covered" >new URLSearchParams(window.location.search),</span>oe=<span class="cstat-no" title="statement not covered" >D.get("ws"),</span>ft=<span class="cstat-no" title="statement not covered" >new URL(`../${oe}`,window.location.toString());<span class="cstat-no" title="statement not covered" ></span>ft.protocol=window.location.protocol==="https:"?"wss:":"ws:";c</span>onst L=<span class="cstat-no" title="statement not covered" >{args:D.getAll("arg"),grep:D.get("grep")||void 0,grepInvert:D.get("grepInvert")||void 0,projects:D.getAll("project"),workers:D.get("workers")||void 0,timeout:D.has("timeout")?+D.get("timeout"):void 0,headed:D.has("headed"),reporters:D.has("reporter")?D.getAll("reporter"):void 0},</span>dt=<span class="cstat-no" title="statement not covered" >navigator.platform==="MacIntel",</span>ne=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>})=&gt;{var ot;const[r,t]=<span class="cstat-no" title="statement not covered" >h.useState(""),</span>[e,s]=<span class="cstat-no" title="statement not covered" >h.useState(!1),</span>[i,d]=<span class="cstat-no" title="statement not covered" >h.useState(new Map([["passed",!1],["failed",!1],["skipped",!1]])),</span>[a,f]=<span class="cstat-no" title="statement not covered" >h.useState(new Map),</span>[n,m]=<span class="cstat-no" title="statement not covered" >h.useState(),</span>[u,g]=<span class="cstat-no" title="statement not covered" >h.useState(),</span>[k,l]=<span class="cstat-no" title="statement not covered" >h.useState({}),</span>[p,x]=<span class="cstat-no" title="statement not covered" >h.useState(new Set),</span>[E,I]=<span class="cstat-no" title="statement not covered" >h.useState(!1),</span>[T,U]=<span class="cstat-no" title="statement not covered" >h.useState(),</span>[O,G]=<span class="cstat-no" title="statement not covered" >Pt("watch-all",!1),</span>[c,j]=<span class="cstat-no" title="statement not covered" >h.useState({value:new Set}),</span>b=<span class="cstat-no" title="statement not covered" >h.useRef(Promise.resolve()),</span>C=<span class="cstat-no" title="statement not covered" >h.useRef(new Set),</span>[$,pt]=<span class="cstat-no" title="statement not covered" >h.useState(0),</span>[gt,mt]=<span class="cstat-no" title="statement not covered" >h.useState(!1),</span>[it,rt]=<span class="cstat-no" title="statement not covered" >h.useState(!0),</span>[w,_t]=<span class="cstat-no" title="statement not covered" >h.useState(),</span>wt=<span class="cstat-no" title="statement not covered" >h.useRef(null),</span>Y=<span class="cstat-no" title="statement not covered" >h.useCallback(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >_t(new Lt(ft.toString()))}</span>,[]);<span class="cstat-no" title="statement not covered" ></span>h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var v;<span class="cstat-no" title="statement not covered" >(v=wt.current)==null||v.focus(),I(!0),Y()}</span>,[Y]),h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!w)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst v=<span class="cstat-no" title="statement not covered" >[w.onStdio(<span class="fstat-no" title="function not covered" >_=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(_.buffer){const y=<span class="cstat-no" title="statement not covered" >atob(_.buffer);<span class="cstat-no" title="statement not covered" ></span>A.write(y)}</span>else <span class="cstat-no" title="statement not covered" >A.write(_.text)}</span></span>),w.onClose(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >mt(!0))</span>];<span class="cstat-no" title="statement not covered" ></span>return A.resize=<span class="fstat-no" title="function not covered" >(_</span>,y)=&gt;{<span class="cstat-no" title="statement not covered" >ct={cols:_,rows:y},w.resizeTerminalNoReply({cols:_,rows:y})}</span>,<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const _ of v)<span class="cstat-no" title="statement not covered" >_.dispose()}</span></span>}</span>,[w]),h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!w)<span class="cstat-no" title="statement not covered" >return;l</span></span>et v;const _=<span class="cstat-no" title="statement not covered" >new qt({onUpdate:<span class="fstat-no" title="function not covered" >S=</span>&gt;{<span class="cstat-no" title="statement not covered" >clearTimeout(v),v=void 0,S?m(_.asModel()):v||(v=setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >m(_.asModel())}</span>,250))}</span>,onError:<span class="fstat-no" title="function not covered" >S=</span>&gt;{<span class="cstat-no" title="statement not covered" >A.write((S.stack||S.value||"")+`</span></span></span></span>
`)},pathSeparator:st}),y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >b.current=b.current.then(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >I(!0);<span class="cstat-no" title="statement not covered" >t</span>ry{const S=<span class="cstat-no" title="statement not covered" >await w.listTests({projects:L.projects,locations:L.args});<span class="cstat-no" title="statement not covered" ></span>_.processListReport(S.report)}</span>catch(S){<span class="cstat-no" title="statement not covered" >console.log(S)}</span>finally{<span class="cstat-no" title="statement not covered" >I(!1)}</span>}</span>)}</span>;<span class="cstat-no" title="statement not covered" ></span>return m(void 0),I(!0),j({value:new Set}),(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await w.initialize({interceptStdio:!0,watchTestDirs:!0});c</span>onst{status:S,report:B}=<span class="cstat-no" title="statement not covered" >await w.runGlobalSetup({});<span class="cstat-no" title="statement not covered" ></span>if(_.processGlobalReport(B),S!=="passed")<span class="cstat-no" title="statement not covered" >return;c</span></span>onst R=<span class="cstat-no" title="statement not covered" >await w.listTests({projects:L.projects,locations:L.args});<span class="cstat-no" title="statement not covered" ></span>_.processListReport(R.report),w.onListChanged(y),w.onReport(<span class="fstat-no" title="function not covered" >P=</span>&gt;{<span class="cstat-no" title="statement not covered" >_.processTestReportEvent(P)}</span>);c</span>onst{hasBrowsers:M}=<span class="cstat-no" title="statement not covered" >await w.checkBrowsers({});<span class="cstat-no" title="statement not covered" ></span>rt(M)}</span>finally{<span class="cstat-no" title="statement not covered" >I(!1)}</span>}</span>)(),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >clearTimeout(v)}</span>}</span>,[w]),h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{config:v,rootSuite:_}=<span class="cstat-no" title="statement not covered" >n,</span>y=<span class="cstat-no" title="statement not covered" >v.configFile?ut.getObject(v.configFile+":projects",void 0):void 0,</span>S=<span class="cstat-no" title="statement not covered" >new Map(a);<span class="cstat-no" title="statement not covered" ></span>for(const B of S.keys())<span class="cstat-no" title="statement not covered" >_.suites.find(<span class="fstat-no" title="function not covered" >R=</span>&gt;<span class="cstat-no" title="statement not covered" >R.title===B)</span>||S.delete(B);<span class="cstat-no" title="statement not covered" >f</span></span>or(const B of _.suites)<span class="cstat-no" title="statement not covered" >S.has(B.title)||S.set(B.title,!!(y!=null&amp;&amp;y.includes(B.title)));<span class="cstat-no" title="statement not covered" >!</span></span>y&amp;&amp;S.size&amp;&amp;![...S.values()].includes(!0)&amp;&amp;S.set(S.entries().next().value[0],!0),(a.size!==S.size||[...a].some(<span class="fstat-no" title="function not covered" >([</span>B,R])=&gt;<span class="cstat-no" title="statement not covered" >S.get(B)!==R)</span>)&amp;&amp;f(S)}</span>,[a,n]),h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >T&amp;&amp;(n!=null&amp;&amp;n.progress)?g(n.progress):n||g(void 0)}</span>,[n,T]);const{testTree:z}=<span class="cstat-no" title="statement not covered" >h.useMemo(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!n)<span class="cstat-no" title="statement not covered" >return{testTree:new at("",new q("","root"),[],a,st)};c</span></span>onst v=<span class="cstat-no" title="statement not covered" >new at("",n.rootSuite,n.loadErrors,a,st);<span class="cstat-no" title="statement not covered" ></span>return v.filterTree(r,i,T==null?void 0:T.testIds),v.sortAndPropagateStatus(),v.shortenRoot(),v.flattenForSingleProject(),x(v.testIds()),{testTree:v}}</span>,[r,n,i,a,x,T]),</span>W=<span class="cstat-no" title="statement not covered" >h.useCallback(<span class="fstat-no" title="function not covered" >(v</span>,_)=&gt;{<span class="cstat-no" title="statement not covered" >!w||!n||v==="bounce-if-busy"&amp;&amp;T||(C.current=new Set([...C.current,..._]),b.current=b.current.then(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{var B,R,M;const y=<span class="cstat-no" title="statement not covered" >C.current;<span class="cstat-no" title="statement not covered" ></span>if(C.current=new Set,!y.size)<span class="cstat-no" title="statement not covered" >return;{<span class="cstat-no" title="statement not covered" ></span></span>for(const P of((B=n.rootSuite)==null?void 0:B.allTests())||[])<span class="cstat-no" title="statement not covered" >if(y.has(P.id)){<span class="cstat-no" title="statement not covered" >P.results=[];c</span>onst tt=<span class="cstat-no" title="statement not covered" >P._createTestResult("pending");<span class="cstat-no" title="statement not covered" ></span>tt[H]="scheduled"}<span class="cstat-no" title="statement not covered" ></span>m</span></span>({...n})}</span>const S=<span class="cstat-no" title="statement not covered" >"  ["+new Date().toLocaleTimeString()+"]";<span class="cstat-no" title="statement not covered" ></span>A.write("\x1B[2m".repeat(Math.max(0,ct.cols-S.length))+S+"\x1B[22m"),g({total:0,passed:0,failed:0,skipped:0}),U({testIds:y}),await w.runTests({locations:L.args,grep:L.grep,grepInvert:L.grepInvert,testIds:[...y],projects:[...a].filter(<span class="fstat-no" title="function not covered" >([</span>P,tt])=&gt;<span class="cstat-no" title="statement not covered" >tt)</span>.map(<span class="fstat-no" title="function not covered" >([</span>P])=&gt;<span class="cstat-no" title="statement not covered" >P)</span>,workers:L.workers,timeout:L.timeout,headed:L.headed,reporters:L.reporters,trace:"on"});<span class="cstat-no" title="statement not covered" >f</span>or(const P of((R=n.rootSuite)==null?void 0:R.allTests())||[])<span class="cstat-no" title="statement not covered" >((M=P.results[0])==null?void 0:M.duration)===-1&amp;&amp;(P.results=[]);<span class="cstat-no" title="statement not covered" >m</span></span>({...n}),U(void 0)}</span>))}</span>,[a,T,n,w]);<span class="cstat-no" title="statement not covered" ></span>h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!w)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst v=<span class="cstat-no" title="statement not covered" >w.onTestFilesChanged(<span class="fstat-no" title="function not covered" >_=</span>&gt;{const y=<span class="cstat-no" title="statement not covered" >[],</span>S=<span class="cstat-no" title="statement not covered" >new Set(_.testFiles);<span class="cstat-no" title="statement not covered" ></span>if(O){const B=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >R=</span>&gt;{const M=<span class="cstat-no" title="statement not covered" >R.location.file;<span class="cstat-no" title="statement not covered" ></span>M&amp;&amp;S.has(M)&amp;&amp;y.push(...z.collectTestIds(R)),R.kind==="group"&amp;&amp;R.subKind==="folder"&amp;&amp;R.children.forEach(B)}</span>;<span class="cstat-no" title="statement not covered" ></span>B(z.rootItem)}</span>else <span class="cstat-no" title="statement not covered" >for(const B of c.value){const R=<span class="cstat-no" title="statement not covered" >z.treeItemById(B),</span>M=<span class="cstat-no" title="statement not covered" >R==null?void 0:R.location.file;<span class="cstat-no" title="statement not covered" ></span>M&amp;&amp;S.has(M)&amp;&amp;y.push(...z.collectTestIds(R))}<span class="cstat-no" title="statement not covered" ></span>W</span></span>("queue-if-busy",new Set(y))}</span>);<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >v.dispose()}</span></span>,[W,w,z,O,c]),h.useEffect(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!w)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >_=</span>&gt;{<span class="cstat-no" title="statement not covered" >_.code==="Backquote"&amp;&amp;_.ctrlKey?(_.preventDefault(),s(!e)):_.code==="F5"&amp;&amp;_.shiftKey?(_.preventDefault(),w==null||w.stopTestsNoReply({})):_.code==="F5"&amp;&amp;(_.preventDefault(),W("bounce-if-busy",p))}</span>;<span class="cstat-no" title="statement not covered" ></span>return addEventListener("keydown",v),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >removeEventListener("keydown",v)}</span>}</span>,[W,Y,w,p,e]);c</span>onst K=<span class="cstat-no" title="statement not covered" >!!T,</span>J=<span class="cstat-no" title="statement not covered" >h.useRef(null),</span>vt=<span class="cstat-no" title="statement not covered" >h.useCallback(<span class="fstat-no" title="function not covered" >v=</span>&gt;{var _;<span class="cstat-no" title="statement not covered" >v.preventDefault(),v.stopPropagation(),(_=J.current)==null||_.showModal()}</span>,[]),</span>Z=<span class="cstat-no" title="statement not covered" >h.useCallback(<span class="fstat-no" title="function not covered" >v=</span>&gt;{var _;<span class="cstat-no" title="statement not covered" >v.preventDefault(),v.stopPropagation(),(_=J.current)==null||_.close()}</span>,[]),</span>xt=<span class="cstat-no" title="statement not covered" >h.useCallback(<span class="fstat-no" title="function not covered" >v=</span>&gt;{<span class="cstat-no" title="statement not covered" >Z(v),s(!0),w==null||w.installBrowsers({}).then(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >s(!1);c</span>onst{hasBrowsers:_}=<span class="cstat-no" title="statement not covered" >await(w==null?void 0:w.checkBrowsers({}));<span class="cstat-no" title="statement not covered" ></span>rt(_)}</span>)}</span>,[Z,w]);<span class="cstat-no" title="statement not covered" ></span>return o.jsxs("div",{className:"vbox ui-mode",children:[!it&amp;&amp;o.jsxs("dialog",{ref:J,children:[o.jsxs("div",{className:"title",children:[o.jsx("span",{className:"codicon codicon-lightbulb"}),"Install browsers"]}),o.jsxs("div",{className:"body",children:["Playwright did not find installed browsers.",o.jsx("br",{}),"Would you like to run `playwright install`?",o.jsx("br",{}),o.jsx("button",{className:"button",onClick:xt,children:"Install"}),o.jsx("button",{className:"button secondary",onClick:Z,children:"Dismiss"})]})]}),gt&amp;&amp;o.jsxs("div",{className:"disconnected",children:[o.jsx("div",{className:"title",children:"UI Mode disconnected"}),o.jsxs("div",{children:[o.jsx("a",{href:"#",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >window.location.href="/",</span>children:"Reload the page"})," to reconnect"]})]}),o.jsxs(Dt,{sidebarSize:250,minSidebarSize:150,orientation:"horizontal",sidebarIsFirst:!0,settingName:"testListSidebar",children:[o.jsxs("div",{className:"vbox",children:[o.jsxs("div",{className:"vbox"+(e?"":" hidden"),children:[o.jsxs(X,{children:[o.jsx("div",{className:"section-title",style:{flex:"none"},children:"Output"}),o.jsx(N,{icon:"circle-slash",title:"Clear output",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >A.clear()}</span>),o.jsx("div",{className:"spacer"}),o.jsx(N,{icon:"close",title:"Close",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s(!1)}</span>)]}),o.jsx(Ht,{source:A})]}),o.jsx("div",{className:"vbox"+(e?" hidden":""),children:o.jsx(ie,{item:k,rootDir:(ot=n==null?void 0:n.config)==null?void 0:ot.rootDir})})]}),o.jsxs("div",{className:"vbox ui-mode-sidebar",children:[o.jsxs(X,{noShadow:!0,noMinHeight:!0,children:[o.jsx("img",{src:"playwright-logo.svg",alt:"Playwright logo"}),o.jsx("div",{className:"section-title",children:"Playwright"}),o.jsx(N,{icon:"color-mode",title:"Toggle color mode",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Mt()}</span>),o.jsx(N,{icon:"refresh",title:"Reload",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Y(),</span>disabled:K||E}),o.jsx(N,{icon:"terminal",title:"Toggle output  "+(dt?"`":"Ctrl + `"),toggled:e,onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s(!e)}</span>}),!it&amp;&amp;o.jsx(N,{icon:"lightbulb-autofix",style:{color:"var(--vscode-list-warningForeground)"},title:"Playwright browsers are missing",onClick:vt})]}),o.jsx(Gt,{filterText:r,setFilterText:t,statusFilters:i,setStatusFilters:d,projectFilters:a,setProjectFilters:f,testModel:n,runTests:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >W("bounce-if-busy",p)}</span>),o.jsxs(X,{noMinHeight:!0,children:[!K&amp;&amp;!u&amp;&amp;o.jsx("div",{className:"section-title",children:"Tests"}),!K&amp;&amp;u&amp;&amp;o.jsx("div",{"data-testid":"status-line",className:"status-line",children:o.jsxs("div",{children:[u.passed,"/",u.total," passed (",u.passed/u.total*100|0,"%)"]})}),K&amp;&amp;u&amp;&amp;o.jsx("div",{"data-testid":"status-line",className:"status-line",children:o.jsxs("div",{children:["Running ",u.passed,"/",T.testIds.size," passed (",u.passed/T.testIds.size*100|0,"%)"]})}),o.jsx(N,{icon:"play",title:"Run all  F5",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >W("bounce-if-busy",p),</span>disabled:K||E}),o.jsx(N,{icon:"debug-stop",title:"Stop  "+(dt?"F5":"Shift + F5"),onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >w==null?void 0:w.stopTests({}),</span>disabled:!K||E}),o.jsx(N,{icon:"eye",title:"Watch all",toggled:O,onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >j({value:new Set}),G(!O)}</span>}),o.jsx(N,{icon:"collapse-all",title:"Collapse all",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >pt($+1)}</span>})]}),o.jsx(ee,{filterText:r,testModel:n,testTree:z,testServerConnection:w,runningState:T,runTests:W,onItemSelected:l,watchAll:O,watchedTreeIds:c,setWatchedTreeIds:j,isLoading:E,requestedCollapseAllCount:$,setFilterText:t})]})]})]})}</span>;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >if(Ft(),window.location.protocol!=="file:"){<span class="cstat-no" title="statement not covered" >if(window.location.href.includes("isUnderTest=true")&amp;&amp;await new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >setTimeout(r,1e3))</span>,!navigator.serviceWorker)<span class="cstat-no" title="statement not covered" >throw new Error(`Service workers are not supported.</span></span></span></span>
Make sure to serve the website (${window.location}) via HTTPS or localhost.`);<span class="cstat-no" title="statement not covered" >navigator.serviceWorker.register("sw.bundle.js"),navigator.serviceWorker.controller||await new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >navigator.serviceWorker.oncontrollerchange=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r()}</span></span>),setInterval(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >fetch("ping")}</span>,1e4)}<span class="cstat-no" title="statement not covered" ></span>Ot.render(o.jsx(ne,{}),document.querySelector("#root"))}</span>)();
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2024-10-24T15:06:32.590Z
            </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    